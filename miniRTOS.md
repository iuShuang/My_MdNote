## **嵌入式中的ISR是什么意思**

ISR在嵌入式系统中通常指"中断服务例程"(Interrupt Service Routine)。它是嵌入式系统中用来处理硬件中断的一段特殊的软件代码。

中断是硬件设备向CPU发出的一种信号,用来通知CPU有某些事件发生,需要CPU立即去处理。ISR就是CPU响应这些中断信号后,所执行的特殊的中断处理程序。

ISR的主要作用包括:

1. 快速响应中断事件,及时处理硬件设备的请求。

2. 保存和恢复CPU寄存器的状态,确保中断处理完成后能够正确地返回到中断之前的执行状态。

3. 完成对中断事件的相应处理,如读取传感器数据、发送控制命令等。

4. 在中断处理完成后,通过返回指令将CPU的执行权交还给之前正在运行的程序。

总之,ISR是嵌入式系统中处理硬件中断的关键部分,是确保系统实时性和响应性的重要机制。合理设计和高效实现ISR对于嵌入式系统的开发非常重要。



## LR寄存器

LR寄存器在嵌入式系统中通常指"链接寄存器"(Link Register)。它是CPU中的一个特殊用途的寄存器,主要用于子程序的调用和返回。

LR寄存器的主要作用如下:

1. 子程序调用:
   - 当执行函数调用指令(如CALL、BL等)时,LR寄存器会自动保存当前程序执行的下一条指令地址。
   - 这样在子程序执行完毕后,可以通过LR寄存器中保存的地址,返回到调用子程序的位置继续执行。

2. 中断返回:
   - 在处理中断服务例程(ISR)时,LR寄存器也会被用来保存中断发生前的执行地址。
   - 中断处理完成后,通过从LR寄存器中恢复地址,可以正确地返回到中断发生前的执行位置。

3. 函数嵌套:
   - 当一个函数内部又调用了其他函数时,LR寄存器会被用来保存内层函数的返回地址。
   - 这样可以确保在内层函数返回后,能够正确地返回到外层函数的执行位置。

总之,LR寄存器在嵌入式系统中扮演着重要的角色,它使得子程序调用、中断处理和函数嵌套等操作得以顺利进行。合理利用LR寄存器对于提高嵌入式系统的执行效率和可靠性非常关键。



## PC寄存器

PC (Program Counter) 寄存器是 CPU 中非常重要的一个寄存器,它的主要作用是:

1. **存储当前指令地址**:
   - PC 寄存器存储着当前正在执行的指令的内存地址。
   - 每执行完一条指令,PC 寄存器会自动加 1(或加上指令长度)以指向下一条指令。

2. **控制程序流程**:
   - PC 寄存器的值决定了 CPU 接下来要执行哪条指令。
   - 通过修改 PC 寄存器的值,可以实现程序流程的跳转,如实现分支、循环、函数调用等。

3. **支持中断处理**:
   - 当发生中断时,CPU 会自动保存 PC 寄存器的值,以便中断处理完成后恢复程序执行。

PC 寄存器是 CPU 执行指令的"指针",它的值决定了 CPU 接下来要执行哪条指令。PC 寄存器的正确使用对于程序的正确执行至关重要。在编写汇编语言程序时,程序员需要密切关注 PC 寄存器的变化情况。

总的来说,PC 寄存器是 CPU 中最核心的寄存器之一,它在程序执行流程控制和中断处理中起着关键作用。



## SP寄存器

SP 寄存器（SP 全称是` Stack Pointer`，即`栈指针寄存器`。）是计算机体系结构中非常重要的一个寄存器,它被用来存储当前程序的栈指针。

具体来说:

1. SP 寄存器存储了当前程序执行时`栈的顶部地址`。栈是一种后进先出的数据结构,用于存储函数调用时的返回地址、参数、局部变量等。

2. 当程序调用函数时,`SP 寄存器的值会被压入栈中,以保存当前的栈指针`。当函数返回时,SP 寄存器会从栈中恢复之前保存的值,以便返回到调用函数的上下文。

3. SP 寄存器的值会随着程序执行而不断变化。在程序开始执行时,SP 寄存器通常被初始化为栈的顶部地址。在函数调用和返回过程中,SP 寄存器会被相应地更新。

4. SP 寄存器的正确使用对于程序的正确执行非常关键。如果 SP 寄存器的值被错误地修改,可能会导致栈溢出、函数调用错误等严重的程序错误。

5. 

## BL指令

BL指令在ARM架构的嵌入式系统中是一个非常重要的指令,它用于实现子程序的调用。"BL"是"Branch with Link"的缩写。

BL指令的主要作用如下:

1. 跳转到目标地址执行子程序
   - BL指令会将当前程序计数器(PC)的值保存到链接寄存器(LR)中。
   - 然后跳转到指定的目标地址,开始执行子程序的代码。

2. 返回到调用点
   - 子程序执行完毕后,可以通过将LR寄存器的值加载回PC寄存器,实现返回到调用BL指令的位置。
   - 这样就可以顺利地从子程序中返回到主程序的执行点。

3. 支持函数嵌套
   - 当一个子程序内部又调用另一个子程序时,BL指令会将当前LR的值再次保存起来。
   - 这样在内层子程序返回后,外层子程序仍然能够正确地返回到调用点。

使用BL指令的优点包括:

- 简单高效:只需要一条指令就可以完成子程序的调用和返回。
- 支持函数嵌套:可以方便地处理函数调用的层次关系。
- 保护现场:通过LR寄存器自动保存返回地址,避免手动保存和恢复现场。

总之,BL指令是ARM架构中非常重要的一条指令,在嵌入式系统的软件设计中扮演着关键的角色。合理使用BL指令能够大大提高嵌入式系统的执行效率和可靠性。

## BL main/普通函数在栈中结构

编译开始，会有汇编BL main指令，即跳转到main开始执行，这个函数也要存入栈。

- LR寄存器值（函数返回地址）

- 局部变量

栈在保存函数返回地址起重要作用

## unsigned在嵌入式变量里的作用

在嵌入式系统中,`unsigned`关键字的主要作用如下:

1. **表示非负整数**: 使用`unsigned`修饰变量可以确保其值永远为非负整数。这在需要表示物理量(如温度、距离、时间等)时很有用,因为这些量通常不会取负值。

2. **扩大数值范围**: 对于相同的字节数,`unsigned`变量可以表示的数值范围是`signed`变量的两倍。例如,一个8位的`signed`变量可以表示的范围是-128到127,而`unsigned`8位变量可以表示0到255。这在需要表示较大数值的场合很有帮助。

3. **优化内存和性能**: 使用`unsigned`可以减少内存占用,因为不需要保留符号位。同时,在某些CPU架构上,`unsigned`运算可以更快,因为不需要处理符号位。

4. **避免无符号整数溢出**: 在嵌入式系统中,内存资源通常比较有限,很容易发生整数溢出的情况。使用`unsigned`可以避免这种情况,因为溢出时会"循环"回到最小值,而不是产生负值。

总之,在嵌入式系统编程中,合理使用`unsigned`关键字可以提高代码的可靠性、效率和可移植性。但需要注意,过度使用`unsigned`也可能带来一些问题,如难以理解负数的含义等,所以需要根据具体需求权衡使用。



## 动态、静态创建任务

- 对于每个任务它都会有一个tcb_t结构体

  - 对于这个结构体,我们可以使用`动态分配`,也可以使用`静态分配`

- 所谓`动态分配`就是在我们的程序里使用这个函数xTaskCreate()来创建任务

  - 在函数内部会使用`malloc`

  - 从动态内存也就是从`堆`里面来分配出这个结构体

  ![image-20240420211113988](D:\A_Document\Routine_Document\实习\学习\image-20240420211113988.png)

  >
  > 传入函数指针，名字，栈大小，参数（这个参数是给这个函数用的），优先级，handle(指向这个tcb结构体)

  - `它的tcb、栈是动态分配的`

  


  所以说我们创建后所返回的handle，他只是取了另外一个名字而已，它就是这个tcb的`指针`

  - 使用这样的handle句柄来表示说某一个对象
  - 我们想去`引用`一个结构体，但是又不想了解它的内部，一般来说使用handle
  - 这个handle只不过是同一个结构体类型的另外一种名称而已
  - 对于任务句柄，它叫做task handle，以后我们还会碰到很多handle

#### 静态创建（事先分配好tcp和栈）

- 需提供空闲

![image-20240420211720092](D:\A_Document\Routine_Document\实习\学习\image-20240420211720092.png)

![image-20240420211817883](D:\A_Document\Routine_Document\实习\学习\image-20240420211817883.png)

​	StaticTask_t为TCB结构体

此外，静态创建还需实现空闲任务，因为`调度器`需要（main.c中会调用调度器）。

![image-20240420213825946](D:\A_Document\Routine_Document\实习\学习\image-20240420213825946.png)

调度器中判断是否为静态创建任务：

![image-20240420213637061](D:\A_Document\Routine_Document\实习\学习\image-20240420213637061.png)

如果是静态创建,则需在main.c中实现空闲任务，因为调度器调用空闲任务。要手动提供：空闲任务的TCB buffer，空闲任务的栈buffer、大小

![image-20240420213536895](D:\A_Document\Routine_Document\实习\学习\image-20240420213536895.png)



## taskhandel有什么用

`TaskHandle_t`是 FreeRTOS 中用于管理任务的一个数据类型。它的主要作用包括:

1. **任务标识**: `TaskHandle_t`可以唯一标识一个任务,用于在代码中引用和操作特定的任务。

2. **任务控制**: 通过 `TaskHandle_t`可以对任务进行`挂起、恢复、删除`等操作。这些操作对于任务调度和管理很重要。

3. **任务信息查询**: 使用 `TaskHandle_t` 可以`查询任务的状态、优先级、堆栈`使用等信息,有助于调试和优化任务。

4. **任务间通信**: `TaskHandle_t` 可以作为`任务间通信的标识`,例如在使用 `xTaskNotify()` 和 `xTaskNotifyWait()` 函数时。

一般情况下,在创建任务时,FreeRTOS 会返回一个 `TaskHandle_t` 类型的变量,用于后续对该任务的操作。例如:

```c
TaskHandle_t xTaskHandle;

// 创建任务
xTaskCreate(vTaskFunction, "TaskName", STACK_SIZE, NULL, PRIORITY, &xTaskHandle);

// 使用 xTaskHandle 操作任务
vTaskSuspend(xTaskHandle);
```

合理使用 `TaskHandle_t` 可以帮助开发者更好地管理和控制 FreeRTOS 系统中的任务,提高嵌入式系统的可靠性和性能。

## stack中的函数

- 一个task在栈中存有头、TCB、局部变量、各种寄存器值（函数返回地址）、**函数参数**。
- 头-记录TCB/局部变量空间大小（100X4）。free的时候向后找`头`。
- 局部变量是从高地址向低地址存储的，如果分配局部变量过大，会破坏前面的信息

![image-20240420164327851](D:\A_Document\Routine_Document\实习\学习\image-20240420164327851.png)

## volatile(【计算机】易改变的)在嵌入式中作用？ 

在嵌入式系统中,`volatile` 关键字的作用主要有以下几个方面:

1. **避免编译器优化**:
   - 嵌入式系统中,很多变量来自于硬件寄存器或者外部设备,它们的值可能会被硬件随时改变。
   - 如果不使用 `volatile` 修饰这些变量,编译器可能会对它们进行过度优化,导致程序无法正确地读取或修改这些变量的值。
   - 使用 `volatile` 可以告诉编译器,不要对这些变量进行优化,每次访问时都要从内存中读取最新的值。

2. **确保内存访问的顺序**:
   - 在多线程/多任务环境下,变量的读写顺序很重要,不当的访问顺序可能会导致竞争条件(race condition)等问题。
   - 使用 `volatile` 可以确保编译器生成的机器码能够严格按照程序员的预期顺序访问内存,避免重排序问题。

3. **提高代码可读性**:
   - 在嵌入式系统中,程序员需要处理大量与硬件相关的变量。
   - 使用 `volatile` 修饰这些变量可以清楚地表明它们来自硬件,而不是普通的软件变量,提高代码的可读性和可维护性。

4. **防止编译器优化死循环**:
   - 在嵌入式系统中,程序经常需要进入死循环等待中断或者外部事件的发生。
   - 如果不使用 `volatile`, 编译器可能会将这些死循环优化掉,导致程序无法正常工作。
   - 使用 `volatile` 可以防止编译器对这些死循环进行优化。

总之,在嵌入式系统编程中,`volatile` 关键字是一个非常重要的工具,它可以帮助程序员更好地控制变量的访问顺序和编译器的优化行为,从而确保程序的正确性和可靠性。

## tick和tick count

- tick中断切换的后该任务执行的时间片
- tick count记录切换次数

![image-20240420171540376](D:\A_Document\Routine_Document\实习\学习\image-20240420171540376.png)

- 发生中断后Tick ISR（tick中断处理函数）判断是否需要切换任务

- 一个tick=每个任务运行的基本时间=定时器产生中断周期=1ms（基准）

  ![image-20240420172417693](D:\A_Document\Routine_Document\实习\学习\image-20240420172417693.png)

- 1000hz=1ms，100hz=10ms（linux中）

- 可以指定不同任务连续执行不同次数tick

  ![image-20240420172627924](D:\A_Document\Routine_Document\实习\学习\image-20240420172627924.png)

  ## RTOS任务四种状态

  > - 运行态
  >   - ->暂停：
  >     - 被动休息进入暂停态
  >     - 在运行中的任务可以调用vTaskSuspend(NULL/自己的handel)，进行主动休息。
  >   - ->阻塞：
  >     - 需要某条件
  >     - 也可主动进入阻塞状态等待一定时间，函数自己调用vTaskDelay(10)=等待10个tick，过了10个tick后直接进入`就绪态`。
  >   - ->就绪态：
  >     - 时间片到了
  > - 就绪态（什么都不缺，随时都可运行）
  >   - ->暂停：
  >     - 运行行态下的任务A，可以掉头vTaskSuspend(B's handel)，让B从就绪态到暂停态
  >   - ->运行态：
  >     - 时间片轮转到自己
  > - 暂停（可能缺，暂时不需要运行，纯粹休息）
  >   - ->就绪态：
  >     - 运行行态下的任务A，可以掉头vTaskResume(B's handel)，让B从暂停态到就绪态
  > - 阻塞（缺运行条件）
  >   - ->就绪态：
  >     - 中断（例 按键按下）
  >     - 在满足资源下，由运行的任务唤醒
  >   -  ->暂停：
  >     - 运行行态下的任务A，可以掉头vTaskSuspend(C's handel)，让c从阻塞到暂停
  >       - 在满足资源下，运行时的A知道C条件满足了，但不想唤醒C，让其运行，会让C进入暂停；
  >       - 在暂停态下的任务只能被别的任务送入就绪态。

  ![image-20240420173251362](D:\A_Document\Routine_Document\实习\学习\image-20240420173251362.png)

  ## 这些任务如何存储

  - 放入List
  - 不同任务状态有不同的List
    - 比如调用vTaskSuspend()暂停某任务,在该函数内部会将该任务存入xSuspendedTaskList

  ![image-20240420183355492](D:\A_Document\Routine_Document\实习\学习\image-20240420183355492.png)

  ## vTaskDelay和vTaskDelayUntil区别

  - vTaskDelay():至少等待指定`个数`的Tick Interrupt才能变为就绪状态

    - `问题`：当任务执行完某些代码后再调用vTaskDelay时。无法确定的是前面的代码要执行多久，所以下次唤醒运行时间不定。

      <img src="D:\A_Document\Routine_Document\实习\学习\image-20240420193526920.png" alt="image-20240420193526920" style="zoom:50%;" />

  - VTaskDelayUntil(t0,△t): `等待到指定的绝对时刻`，才能变为就绪态

    - `解决`：进入程序记录当前tick-t0，加上延时多少tick △t。下次唤醒时间确定。

    - `让任务的启动呈周期性`

    - VTaskDelayUntil做两件事：

      - 计算到哪个tick开始变为就绪态

      - 更新t0

        ![image-20240420194745392](D:\A_Document\Routine_Document\实习\学习\image-20240420194745392.png)

        为什么更新t0，因为只获取一次当前tick给tStart后，后面都在while循环中。

        ![image-20240420194820559](D:\A_Document\Routine_Document\实习\学习\image-20240420194820559.png)



	## #if/#else是什么意思

`#if` 和 `#else` 是 C 预处理器指令,用于在编译时根据某些条件来选择性地包含或排除代码块。

具体来说:

1. `#if` 指令后跟一个条件表达式,如果该条件为真(非零值),则包含该 `#if` 和 `#endif` 之间的代码块。

2. `#else` 指令用于在 `#if` 条件为假的情况下,提供一个备用的代码块。

3. `#endif` 指令标记 `#if` 条件块的结束。

这些预处理指令允许程序员根据特定的编译时条件来选择性地包含或排除代码,从而实现编译时的条件编译。这在需要针对不同平台、编译器或配置进行代码定制时非常有用。

例如:

```c
#if defined(DEBUG)
    // 这段代码只在 DEBUG 模式下编译
    printf("Debug information\n");
#else
    // 这段代码在非 DEBUG 模式下编译
    // ...
#endif
```

## 空闲任务钩子函数(空闲任务优先级为0)

task2由task1创建（分配空间）、删除（由空闲任务删除）

由task1调用vTaskDelete函数删除，删除后返回task1。

![image-20240420205124817](D:\A_Document\Routine_Document\实习\学习\image-20240420205124817.png)

但由task2自己调用vTaskDelete自杀，无法返回task2。即自己无法清理自己的尸体；无法释放内存，该内存会泄漏。

![image-20240420205113030](D:\A_Document\Routine_Document\实习\学习\image-20240420205113030.png)

必须引出空闲任务完成这些工作，来释放内存。`系统提供了一个钩子函数：程序需开始时，由启动调度器来创建空闲任务`。

![image-20240420204322370](D:\A_Document\Routine_Document\实习\学习\image-20240420204322370.png)

#### 总结

- 删除任务后的清理工作，是在空闲任务中完成的，比如释放任务的内存

- 空闲任务何时才能执行?
- 空闲任务只能处于这2个状态之一: Running、Ready

- 空闲任务钩子函数
  - 执行一些低优先级的、后台的、需要连续执行的函数
  - 测量系统的空闲时间: 空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任
    务占据的时间，就可以算出处理器占用率。
  - 让系统进入省电模式:空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式
  - 限制：绝对不能导致任务进入Blocked、Suspended状态（阻塞了没任务会唤醒它）
  - 建议：如果你会使用 VTaskDelete() 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务一直卡在钩子函数里的话，它就无法释放内存

## 调度策略

#### 抢占：

![image-20240421192731036](D:\A_Document\Routine_Document\实习\学习\image-20240421192731036.png)

- 配置可抢占模式时：
  - 若高优先级任务无释放，会一直执行，所以一般会在高优先级中加入delay(),让其执行完放弃CPU()一会。这时其他低优先级任务才能执行。
  - 相同优先级任务可设置为交替执行（抢占同优先级）
  - 高优先级唤醒会立即执行 (抢占低优先级)
- 配置不可抢占模式(设为0)：
  - 一旦有程序进入CPU，除非自己delay()，否则不会退出，即使存在高优先级任务在等待执行。

#### 交替执行：

![image-20240421193510573](D:\A_Document\Routine_Document\实习\学习\image-20240421193510573.png)

- 当设置`不使用时间片轮转（0）`。同优先级任务先到先得，且不会把CPU让给同优先级任务。

#### 空闲任务礼让

![image-20240421194234010](D:\A_Document\Routine_Document\实习\学习\image-20240421194234010.png)

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240421194550560.png" alt="image-20240421194550560" style="zoom:50%;" />

- 设置不礼让：空闲任务优先级为0，此时会如同其他优先级为0的任务一样执行完所有才让出CPU。

  <img src="D:\A_Document\Routine_Document\实习\学习\image-20240421194748876.png" alt="image-20240421194748876" style="zoom:80%;" />

- 设置礼让：低于0优先级任务一等。也具有轮转特性，但会被>=0优先级的任务抢占。

  <img src="D:\A_Document\Routine_Document\实习\学习\image-20240421194708843.png" alt="image-20240421194708843" style="zoom: 80%;" />

## 汇编里LR是什么的缩写

在 ARM 汇编语言中,LR 是 Link Register 的缩写。

Link Register (LR) 是 ARM 处理器中的一个特殊目的寄存器,主要用于以下两个方面:

1. 函数调用时保存返回地址:
   - 当一个函数被调用时,CPU 会自动把当前执行位置(即下一条指令的地址)保存到 LR 寄存器中。
   - 函数返回时,可以从 LR 寄存器中取出返回地址,继续执行调用函数的剩余部分。

2. 实现过程间跳转:
   - LR 寄存器可以用来保存过程间跳转的目标地址。
   - 通过 BLX (Branch and Link Exchange) 指令可以跳转到 LR 寄存器保存的地址并更新 LR 寄存器。

总之,LR 寄存器在 ARM 汇编语言中扮演着重要的角色,是实现函数调用和过程间跳转的关键。理解 LR 寄存器的作用有助于更好地理解 ARM 汇编语言的程序流程控制。



![image-20240422135144353](D:\A_Document\Routine_Document\实习\学习\image-20240422135144353.png)

![image-20240422135202295](D:\A_Document\Routine_Document\实习\学习\image-20240422135202295.png)

![image-20240422135028394](D:\A_Document\Routine_Document\实习\学习\image-20240422135028394.png)

因为这里进入了一个子函数add_val()，lr就是返回地址就是执行完子函数的下一条函数地址



## 被中断怎么保存现场？

- 任务（运行中的函数）：函数+栈+优先级；
- 为什么要有栈：
  - 因为在这个函数运行的时候，它有`调用关系`，`局部变量`，都保存在栈里面，这个任务有可能被暂停，暂停的时候，那`cpu寄存器`也都得保存在栈里面

- 当任务执行中被中断，要保存现场（CPU内所有寄存器）到该任务的栈中（在内存RAM中）。

![image-20240422144832725](D:\A_Document\Routine_Document\实习\学习\image-20240422144832725.png)





## 三种现场保护

现场保护、处理子函数/中断/任务切换、恢复现场

如何保护：

- 任务调度
  - 调用子函数时，有些寄存器作为向子函数传参用的（例R0,R1,R2），无需保存到栈中。
    - R0,R1,R2寄存器一般为函数的形参。
- 硬件中断
  - 也无需保存所有寄存器到栈中。
    - 1-硬件会自动将一些寄存器（R0,R1,R2）存入栈中，无需代码实现
    - 2-软件保存一些常用寄存器（LR,PC,R7...）
- 任务切换
  - 保存所有寄存器
    - 因为它与另一任务毫无关系



## 如何创建任务

- 函数是静态存放在flash中的。
- 通过任务创建函数（核心参数：函数指针，栈大小`<1000x4>`，优先级），创建任务后，到栈（内存中）。

![image-20240422155334687](D:\A_Document\Routine_Document\实习\学习\image-20240422155334687.png)

#### 对于参数（别名、优先级、栈大小大小）：

> 每个任务都有自己的栈，那栈从哪里分配？任务栈大小怎么确定？

答：

1. RTOS中先向内存申请一块空闲的区域用巨大的数组来管理该区域，从该数组内划分一块空间，分给某个任务作为栈，该栈的起始空间就存在`pxStack中`。

   ​	              <img src="D:\A_Document\Routine_Document\实习\学习\image-20240422163726475.png" alt="image-20240422163726475" style="zoom:50%;" />

![image-20240422163543590](D:\A_Document\Routine_Document\实习\学习\image-20240422163543590.png)

​       1）由高地址向低地址分配。分配好后，用低地址+偏移量来使用栈

2.  局部变量大小+调用关系确定。以某函数为例：

   1）有两个局部变量，数组+tmp；

   <img src="D:\A_Document\Routine_Document\实习\学习\image-20240422155530879.png" alt="image-20240422155530879" style="zoom: 67%;" />

   2）无调用关系，所以不会覆盖调LR，所以不用存储LR寄存器值。

   - 每个函数都有返回值，存在cpu内的LR寄存器内。

   ![image-20240422161814111](D:\A_Document\Routine_Document\实习\学习\image-20240422161814111.png)

   3）所以此时栈的大小=数组大小+临时变量大小

   <img src="D:\A_Document\Routine_Document\实习\学习\image-20240422161403356.png" alt="image-20240422161403356" style="zoom:67%;" />

   4） 加入函数调用：

   <img src="D:\A_Document\Routine_Document\实习\学习\image-20240422162530560.png" alt="image-20240422162530560" style="zoom:50%;" />

   5）汇编中首先做的就是将LR存入栈中：

   ![image-20240422162659489](D:\A_Document\Routine_Document\实习\学习\image-20240422162659489.png)

   6）如何手动分配栈大小：只能估计

#### 对于参数（`函数指针`，`函数参数`）：

> 任务创建时，传入的`函数指针`，`参数`为什么没在结构体中出现？

- 当一个任务开始运行时，PC存该函数指针，R0存参数。

- 所以该任务被创建，直接将`函数指针`、`参数`放在该任务的栈中`R15、R0`。无需存入在TCB结构体中

  - 例如任务切换，会把所有寄存器的值存入栈中。
  - 而恢复任务时也会恢复各种寄存器的值。
  - 而局部变量和调用关系也会放入寄存器中。

  <img src="D:\A_Document\Routine_Document\实习\学习\image-20240422171240770.png" alt="image-20240422171240770" style="zoom: 80%;" />

## 任务调度

- 就绪态、阻塞态、暂停态：这些任务存储在链表中。创建三个任务：

  ![image-20240422194148505](D:\A_Document\Routine_Document\实习\学习\image-20240422194148505.png)

#### 就绪态：

- 假设这三个任务都满足运行条件，则会进入就绪态

- 就绪态下，设置五个不同优先级的链表：

   ![image-20240422194229707](D:\A_Document\Routine_Document\实习\学习\image-20240422194229707.png)

-  从上往下找，高优先级链表任务先执行。同优先级任务轮流执行，执行玩挂在`链表后面`。

#### 谁调度任务？

- `tick中断函数`。所以tick中断就是每隔固定的时间会产生的一个`定时器`中断。
  - 定时器还可以让我们去设置

#### 具体过程：

- 每隔1ms都会产生一个中断，产生中断之后，就会调用到`tick中断函数`。

  - 在这中断函数里面就要`遍历就绪链表`。去取出下一个任务、切换。

- 怎么切换呢：

  - 先保存当前任务、恢复新任务

    ![image-20240422200415387](D:\A_Document\Routine_Document\实习\学习\image-20240422200415387.png)

#### 如何阻塞任务

- 高优先级的task3主动delay，则vTaskDelay()会将就绪链表里的task3,转移到DelayList

![image-20240422210003944](D:\A_Document\Routine_Document\实习\学习\image-20240422210003944.png)

![image-20240422205822453](D:\A_Document\Routine_Document\实习\学习\image-20240422205822453.png)

#### 如何恢复任务

- tick中断函数每个tick查询task是否延时结束。
- 如果达到该tick：
  - 把task3放入ReadList[2]。
  - 调度运行（task3优先级最高）

![image-20240422210324139](D:\A_Document\Routine_Document\实习\学习\image-20240422210324139.png)

- 总体来说：每个tick，先刷新3类list，再按照ReadList执行



#### 多个相同优先级的任务先执行哪一个？

- 在创建新任务时，会把新任务放入就绪链表里。在添加任务到就绪链表的函数里有代码如下：

![image-20240422210856790](D:\A_Document\Routine_Document\实习\学习\image-20240422210856790.png)

- 若大于或等于这个当前任务的优先级，则让新任务作为当前任务。

  ![image-20240422213658750](D:\A_Document\Routine_Document\实习\学习\image-20240422213658750.png)

- `假如按顺序创建相同优先级(>0)的1,2,3个任务。则执行顺序：3,1,2；`

  ![image-20240422213536354](D:\A_Document\Routine_Document\实习\学习\image-20240422213536354.png)



## 几个不同的栈（SP寄存器）

- 对于main函数分配一个栈(msp)，系统的中断函数也是用这个栈
- 其他任务有自己的栈(sp)，task1~3的、空闲任务的。

![image-20240422212803518](D:\A_Document\Routine_Document\实习\学习\image-20240422212803518.png)



## 如何实现空闲任务礼让

- 如果有同是优先级0的其他就绪任务，空闲任务主动放弃一次运行机会	

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240423130056393.png" alt="image-20240423130056393" style="zoom: 80%;" />

![image-20240423130005645](D:\A_Document\Routine_Document\实习\学习\image-20240423130005645.png)

具体流程：

- 配置可抢占+空闲任务礼让为1
- 在空闲任务中会判断ReadList[0]的链表长度是否>1（空闲任务在其中）
- 如果是，在空闲任务中会调度taskYIELD();
  - 调度其他任务执行运行
  - 其他任务运行完后，空闲任务继续从该处往下运行



## 什么情况下中途放弃运行？

![image-20240423130928177](D:\A_Document\Routine_Document\实习\学习\image-20240423130928177.png)

以下皆为当前tick未运行完：

1. 主动放弃：例如当前任务读队列数据，但队列数据为空，调用vTaskDealy主动放弃。
2. 被动放弃：GPIO中断。向队列写数据。在休眠状态的高优先级task4（从队列读数据的条件满足）被唤醒
3. task4抢占，立即执行。占用task1剩余的0.1ms。



## 如果设置为不抢占、不礼让

- 空闲任务函数里，先执行僵尸任务的内存清理；

- 然后判断是否可抢占
- 如果不能抢占，永远直接礼让。

![image-20240423135650317](D:\A_Document\Routine_Document\实习\学习\image-20240423135650317.png)

- 中断任务（无论多么低得优先级中断任务）比任何任务的优先级都高



## 为什么引入互斥

答：多任务机制的引入，可能会造成任务访问变量时不是原子化操作。**即某任务正在访问变量a，中途打断被B任务，会造成不是预期结果**，需引入互斥机制。

- 假设要实现让a=2....等累加，传统的如下左图。右下图为**多任务系统**：

​	![image-20240424154638422](D:\A_Document\Routine_Document\实习\学习\image-20240424154638422.png)

假设两个任务A,B都要执行任务：a++：

- 单一步骤：1、从内存中读a到寄存器；2、修改；3、写入内存

![image-20240424154351190](D:\A_Document\Routine_Document\实习\学习\image-20240424154351190.png)

- 若用第一个方法累**加结果肯定为2**。但在多任务系统中要考虑互斥，因为在A访问变量a时。
  - **若发生中断**，则会保存CPU内寄存器的值（现场）到**自己的栈中**。
  - 运行任务B时，会重新读入变量a到寄存器中，运行完后a=1。
  - 恢复A，其自己栈中的a仍为0。
  - A中a++后覆盖B任务结果，得到a=1；

![image-20240424155056423](D:\A_Document\Routine_Document\实习\学习\image-20240424155056423.png)



## 怎么实现互斥访问

答：关中断、链表、环形缓冲区。

![image-20240425150913288](D:\A_Document\Routine_Document\实习\学习\image-20240425150913288.png)

A、C写数据a。B读数据A。在多任务系统中，两个任务同时访问一个变量会引起问题。

- 引入一个缓冲区（队列）**，存储多任务写的结果（B可能读的不够快）**。

  <img src="D:\A_Document\Routine_Document\实习\学习\image-20240425151454422.png" alt="image-20240425151454422" style="zoom: 50%;" />

- 对变量a进行互斥访问，**引入关开中断机制**。

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425151628344.png" alt="image-20240425151628344" style="zoom:50%;" />

- 关掉的中断包括tick中断。

  - 如果定时器中断不关**会引起调度**

- 关了中断系统仍然能跑，就像**裸机程序**。A关了中断，系统无中断，都是A在运行。

  ![image-20240425151859337](D:\A_Document\Routine_Document\实习\学习\image-20240425151859337.png)

## 使用队列的两个好处

- 休眠唤醒

  - 假设两个任务A、B；只有当A生产完后，B才能运行。

    - 如果使用flag机制：当A生产完就让flag=1。B判断flag再运行后面代码。

    - 这样会造成，A和B在tick交替运行。每次运行B都要判断B的flag是否为1。

    - 严重浪费CPU。（如果满足还要读出某A生产的某个数组数据）

    - 不如将A生产的东西放入队列，B直接判断队列生产的是否满足，如果不满足就让其休眠进入阻塞态。

      ![image-20240425153342524](D:\A_Document\Routine_Document\实习\学习\image-20240425153342524.png)

      <img src="D:\A_Document\Routine_Document\实习\学习\image-20240425153330670.png" alt="image-20240425153330670" style="zoom:50%;" />

- 提高CPU的利用率

  - 每个tick中断时，顺便判断等待这个队列的任务是否被满足即可，而不是分配一个tick给B去判断。

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425153638378.png" alt="image-20240425153638378" style="zoom:50%;" />



## 消息队列的核心

1. 关中断：实现互斥
2. 环形缓冲区：保存数据
3. 链表（记录task）：实现休眠和唤醒

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425155558559.png" alt="image-20240425155558559" style="zoom: 67%;" />

- 对于写任务来说，每次往队列里写数据，写完之后就会唤醒QueueList**（结构体表示）**中满足条件的任务。

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425160616140.png" alt="image-20240425160616140" style="zoom:67%;" />

- 对于读任务来说：

  1. 先从就绪队列转到阻塞队列
  2. 存入该队列的链表里

- 环形缓冲区的实现：

  - 数组实现。R/W%len(buf)

  <img src="D:\A_Document\Routine_Document\实习\学习\image-20240425161756987.png" alt="image-20240425161756987" style="zoom: 50%;" />

## 消息队列的结构体和读流程

- 消息队列结构体应实现两种需求：
  - B任务读不到，记录该任务。
  - A任务写的时候队列满了，记录该任务。
  - 用两个链表来记录上述任务。

![image-20240425162554792](D:\A_Document\Routine_Document\实习\学习\image-20240425162554792.png)

#### 结构体如下：

- **读写位置R,W(唤醒缓冲区)**
- **两个链表-等读、等写**

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425163620112.png" alt="image-20240425163620112" style="zoom: 200%;" />

#### 队列创建函数：

![image-20240425193530161](D:\A_Document\Routine_Document\实习\学习\image-20240425193530161.png)

- 传入：长度+元素大小+类型 

![image-20240425163647245](D:\A_Document\Routine_Document\实习\学习\image-20240425163647245.png)

#### 分配大小：

- **队列头（结构体大小）+队列buffer大小**

![image-20240425163746806](D:\A_Document\Routine_Document\实习\学习\image-20240425163746806.png)



#### 读数据过程：

1. 先关中断，因为有可能多个任务在读（数据被读了，指针会后移）。

2. 判断是否有数据：

   1. 无数据：

      1. 返回ERR

      2. 休眠{

         ​	步骤1：放入消息队列的读链表；

         ​	步骤2：从就绪态转换到阻塞态；

         }

   2. 有数据 {

      ​	步骤1：拷贝数据；

      ​	步骤2：唤醒消息队列写数据链表中的任务（因为之队列前满了）；

      ​		移除链表第一个任务

      ​		阻塞转到就绪链表

      }

​	![image-20240425164442754](D:\A_Document\Routine_Document\实习\学习\image-20240425164442754.png)

![image-20240425171052267](D:\A_Document\Routine_Document\实习\学习\image-20240425171052267.png)

#### 代码如下：

![image-20240425170350279](D:\A_Document\Routine_Document\实习\学习\image-20240425170350279.png)

- 其xQueueReceive内部：

  ![](D:\A_Document\Routine_Document\实习\学习\image-20240425184637248.png)

  - 其中，如果队列无数据：
    - 不愿意等待

![image-20240425185319043](D:\A_Document\Routine_Document\实习\学习\image-20240425185319043.png)

- 如果愿意等：

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425185706611.png" alt="image-20240425185706611" style="zoom:67%;" />



## 写消息队列的过程

- 类似于读数据过程：

![image-20240425190530318](D:\A_Document\Routine_Document\实习\学习\image-20240425190530318.png)

#### 当消息队列为空，每个读任务还可已选择等待指定tick时间：

- 每个等待的任务都会挂在阻塞链表里，按时间从小达到大存放；
  - 这里的timeout=当前系统tick次数+延迟多少tick数
- 系统每此tick中断都会+1，都会判断链表里是否有到达时间的任务。

![image-20240425192111270](D:\A_Document\Routine_Document\实习\学习\image-20240425192111270.png)

如果有时间到了的任务：

- 详细代码：

![image-20240425191821192](D:\A_Document\Routine_Document\实习\学习\image-20240425191821192.png)

## 信号量

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425194219455.png" alt="image-20240425194219455" style="zoom:67%;" />

#### 信号量是一种特殊的队列

#### 消息队列用来传数据、信号量表示资源个数

- 背景：

  - 在裸机开发中，可以用一个变量来表示信号量，因为函数无法同时运行。

    ![image-20240425194123876](D:\A_Document\Routine_Document\实习\学习\image-20240425194123876.png)

  - 但是在多任务系统中，**信号量会被多任务同时访问（如停车场）**

    - 引入保护机制，同一时刻只能一个任务访问
    - **引入休眠-唤醒机制，提高CPU利用率**

  ![image-20240425194948822](D:\A_Document\Routine_Document\实习\学习\image-20240425194948822.png)

- 在消息队列里**，队列放的是数据的拷贝。**

- 但在`信号量里是计数值的++，--`其他结构与消息队列（结构体）一样。



## 获取信号量流程

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425195526495.png" alt="image-20240425195526495" style="zoom:67%;" />

## 释放信号量流程

![image-20240425200138714](D:\A_Document\Routine_Document\实习\学习\image-20240425200138714.png)

## 一些信号量相关代码：

#### 信号量本质是队列：

- 如下图，传入的**第一个参数为1，表示队列长度**;
- 第二个参数表示item大小**，设为0；**

![image-20240425200719720](D:\A_Document\Routine_Document\实习\学习\image-20240425200719720.png)

![image-20240425200505815](D:\A_Document\Routine_Document\实习\学习\image-20240425200505815.png)

- 因为item大小设0，所以信号量的结构大小只包含队列头，不包含buffer部分。用`队列头表示信号量`就够了

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425200827245.png" alt="image-20240425200827245" style="zoom: 50%;" />

- 在消息队列有有一个元素来表示队列有多少个有效数据： 

  ![image-20240425201250337](D:\A_Document\Routine_Document\实习\学习\image-20240425201250337.png)

#### 读信号量：

- 在信号量里，可用这个元素表示信号量整数值。
  - 度信号量代码如下：

![image-20240425201521535](D:\A_Document\Routine_Document\实习\学习\image-20240425201521535.png)

**读信号的其余代码、结构与读消息队列差不多**。

#### 释放信号量：

![image-20240425201826658](D:\A_Document\Routine_Document\实习\学习\image-20240425201826658.png)

释放过程必然成功，无需像写队列一样等待（timeout设置等待时间）。

**释放信号的其余代码、结构与读消息队列差不多**。

#### 还有二进制信号量：

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240425200251140.png" alt="image-20240425200251140" style="zoom: 80%;" />



## 互斥量

#### 互斥量和信号量里的二进制有什么区别？

-  比信号量**多了一个优先级继承**

![image-20240425205542038](D:\A_Document\Routine_Document\实习\学习\image-20240425205542038.png)

#### 先引入一个现象：

#### 优先级翻转：

- 信号量为2；

- LPTask获得一个，MPTask抢占CPU也获得一个。

- 还未释放HPTaks抢占CPU但，无信号量了。
- 若MPTask一直运行，不释放semaphore。
- 则LPTask无法运行/无法释放semaphore->HPTaks饿死。
- 出现优先级翻转

![image-20240425210214611](D:\A_Document\Routine_Document\实习\学习\image-20240425210214611.png)



- 注：关中断的临界代码段就几行代码（SemphoreTake（）），LP的任务函数后面还很长要执行，后面中断已经打开了

- 注：获得信号量之后就开中断了啊，关中断是为了实现原子操作，防止获取/给与信号量器件发生调度被打断

#### 如何解决优先级翻转？

使用优先级继承的方法:

- 把信号量改成互斥量。
- 低优先级获得互斥量后，中优先级任务抢占CPU，但不需求互斥量
- 高优先级抢占CPU，需求互斥量：
  - 提升`低优先级且拥有该互斥量任务`的优先级。让其快速运行完。
  - 被提升的任务执行完后释放互斥量，恢复优先级、唤醒高优先级。

​	![image-20240426204105621](D:\A_Document\Routine_Document\实习\学习\image-20240426204105621.png)

#### 互斥量代码：

- 互斥量同样是特殊的队列，除了核心的几块代码不同，其他结构相同。

![image-20240426204815069](D:\A_Document\Routine_Document\实习\学习\image-20240426204815069.png)

![image-20240426205153943](D:\A_Document\Routine_Document\实习\学习\image-20240426205153943.png)

- 高优先级任务如果愿意等待，先进入等待区代码

  - 在等待区中，判断该队列是否为互斥量
    - 若为则进行**优先级继承**

  ![image-20240426205836512](D:\A_Document\Routine_Document\实习\学习\image-20240426205836512.png)

  - 在优先级继承的函数中：

![image-20240426210306787](D:\A_Document\Routine_Document\实习\学习\image-20240426210306787.png)

![image-20240426210343775](D:\A_Document\Routine_Document\实习\学习\image-20240426210343775.png)

- 优先级恢复

  - 如果采用优先级继承，会有变量记录其原来的优先级

     		![image-20240426210831209](D:\A_Document\Routine_Document\实习\学习\image-20240426210831209.png)

  - 在该拥有者释放时有代码：

    - 如果使用了互斥量，则恢复优先级

    ![image-20240426211200928](D:\A_Document\Routine_Document\实习\学习\image-20240426211200928.png)

    - 该函数详细代码：

    ​	 ![image-20240426211352789](D:\A_Document\Routine_Document\实习\学习\image-20240426211352789.png)

    

## 事件组用在什么场合？

- 某任务等待**多种**事件或**多种事件中**的某一件发生。

  - 不同于消息队列的单一读存数据。

  - 设bit任务为1的任务不会阻塞

    ![image-20240427133706790](D:\A_Document\Routine_Document\实习\学习\image-20240427133706790.png)

## 事件组如何用？

- 事件组与上面的**几个代码结构不同（非队列实现）**。

- 在消息队列中，防止资源抢占，会关中断：

  - 关闭调度器，是为了**防止任务B**抢占队列。
  - 关闭中断，是为了防止中断后**任务调度**（关中断后调度器无法运行）和**其他中断函数**使用队列。
  - 所以直接关中断就行。

  

  ![image-20240427132931737](D:\A_Document\Routine_Document\实习\学习\image-20240427132931737.png)

- 而在事件组里，中断函数不会使用事件组。所以只需关闭调度器即可。

#### 创建事件组

![image-20240427141310739](D:\A_Document\Routine_Document\实习\学习\image-20240427141310739.png)

- 对于（2）等待：使用事件组所需传入的参数

- 事件组的结构体核心有两个：
  - 事件位uxEventBits
  - 当前等读事件的链表xTaskWaitingForBits

![image-20240427133907475](D:\A_Document\Routine_Document\实习\学习\image-20240427133907475.png)



#### 任务设置事件组

![image-20240427134423196](D:\A_Document\Routine_Document\实习\学习\image-20240427134423196.png)

- 设置事件
- 唤醒等事件链表上的任务
  - 如果等bit0位的任务有多个，则都唤醒（类似于广播）
  - 不同于消息队列，只唤醒一个任务。

#### 任务来使用事件组

![image-20240427140928979](D:\A_Document\Routine_Document\实习\学习\image-20240427140928979.png)

![image-20240427140940507](D:\A_Document\Routine_Document\实习\学习\image-20240427140940507.png)

#### 事件组函数内部

![image-20240427141600209](D:\A_Document\Routine_Document\实习\学习\image-20240427141600209.png)

## 事件组如何关停调度器

- 用一个变量来表示是否关闭调度器。
- 每当有任务获取事件组，就让uxSchedulerSuspended变量++；

​		 ![image-20240427142229337](D:\A_Document\Routine_Document\实习\学习\image-20240427142229337.png) 

![image-20240427142145937](D:\A_Document\Routine_Document\实习\学习\image-20240427142145937.png)

#### 事件组为何不关中断

- 中断不会去给事件组值的设置

- 因为设计的是：中断函数中创建“**守护任务**”。用守护任务去设置事件组

- 而守护任务只能被等待调度，不会抢占CPU。

- 为何不在中断里设值：

  - 设置后可能会满足多个等待任务。触发多个任务且被中断的任务还没运行完---不可控。

  ![image-20240427150827838](D:\A_Document\Routine_Document\实习\学习\image-20240427150827838.png)

## 任务通知

- 与上述任务交互方法不同：

  - 不需要创建（队列、信号量等结构体）

    <img src="D:\A_Document\Routine_Document\实习\学习\image-20240427153518526.png" alt="image-20240427153518526" style="zoom: 80%;" />

  - 直接在task结构体中创建两个变量，接受某任务的通知：

    - state：0（不等）/1（等）/2（等到）
    - val：接收值

    ![image-20240427153541491](D:\A_Document\Routine_Document\实习\学习\image-20240427153541491.png)

    ![image-20240427155810667](D:\A_Document\Routine_Document\实习\学习\image-20240427155810667.png)

    ![image-20240427160129171](D:\A_Document\Routine_Document\实习\学习\image-20240427160129171.png)

#### 等通知的两种情况

 - 情况1，需求前就已经发过来了：

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240427160340808.png" alt="image-20240427160340808" style="zoom:67%;" />

- 情况2，需求后再发来：

  ![image-20240427160554686](D:\A_Document\Routine_Document\实习\学习\image-20240427160554686.png)

​		

#### 发通知和等通知：

![image-20240427160706549](D:\A_Document\Routine_Document\实习\学习\image-20240427160706549.png)

## 软件定时器原理

- 软件定时器结构体：

  ![image-20240427162510796](D:\A_Document\Routine_Document\实习\学习\image-20240427162510796.png)

  - 定时到达时所需运行的**函数func（优先级可以手动设定）**
  - 软中断时间=系统时钟+延时时长
  - 属性：周期性还是一次性

> 1. 软中断链表，记录系统设置的软中断，**会按超时时间从小到大排序**
>
> 2. 每个tick都会去该链表上找寻时间到达的任务
>    - 在硬件中断内调用软件中断中的func
>    - 但在freeRtos中不同：
>      - freeRtos认为在硬中断中执行软中断的func函数，由于无法把我软中断函数中的func执行时长，所以会担心影响整个系统。
>      - 所以，freeRtos不在定时器中断中，调用func

![image-20240427162933609](D:\A_Document\Routine_Document\实习\学习\image-20240427162933609.png)

#### freeRTOS使用定时器队列来管理定时器（func函数）

- 如果软定时器时间到，写入定时器队列
- 创建一个`定时器管理任务TimerTask`
  - 可以对队列中的定时器进行 1、启动或停止；2、修改；3、调用func函数

![image-20240427164415567](D:\A_Document\Routine_Document\实习\学习\image-20240427164415567.png)

- 注：创建和启动后的定时器都可放入TimerQueue中进行管理

#### 代码部分

#### 定时器结构体

![image-20240427165526061](D:\A_Document\Routine_Document\实习\学习\image-20240427165526061.png)

#### 创建定时器：

![image-20240427165257780](D:\A_Document\Routine_Document\实习\学习\image-20240427165257780.png)

#### 启动定时器

- 写队列都需要有个等待时间，因为队列有可能已经满了
- 消息：就是要对这个定时器的操作。

![image-20240427170558154](D:\A_Document\Routine_Document\实习\学习\image-20240427170558154.png)

#### 启动定时器流程：

- 启动它的时候就是去`构造一个消息`。把这个消息写入这个队列

- 有一个任务呢会去读这个队列、读出这个消息

- 根据这个消息的参数发现你是想去启动这个定时器

  ![image-20240427170919848](D:\A_Document\Routine_Document\实习\学习\image-20240427170919848.png)

- 于是我就把你这个定时器的这个结构体放入**等待中断链表**

- 放入这个**等待中断链表**就完事了

  ![image-20240427170952127](D:\A_Document\Routine_Document\实习\学习\image-20240427170952127.png)

#### 处理定时器的过程

- 上面的那个链表只起到记录时间并唤醒。
- 重要的是**定时器队列xTimerQueue**和**定时器管理任务TimerTask**：
  - 一个在**等待中断**的定时器可以被**定时器管理任务**发个**消息**进而唤醒
  - 所以一个定时器被唤醒的两种方式：
    - 软中断时间到了
    - 管理任务发来消息

![image-20240427172140622](D:\A_Document\Routine_Document\实习\学习\image-20240427172140622-1714216498550-3.png)

## 两种写队列函数接口区别

- 普通任务写队列

  - 队列满了，可选择休眠
  - 唤醒等读队列中的任务从阻塞链表到就绪链表
  - 还会在就绪链表挑出最高优先级的任务运行

- 中断任务写队列

  - 队列满了，也不可休眠，返回“错误”
  - 同样可唤醒等读队列中的任务，使其从阻塞链表到就绪链表
  - 但不会在就绪链表挑出最高优先级的任务运行
  - 只是通过pxHigherPriorityTaskWoken记录是否有高优先级的任务被唤醒

  ![image-20240427191555150](D:\A_Document\Routine_Document\实习\学习\image-20240427191555150.png)

#### 为何中断中不会在就绪链表挑出最高优先级的任务运行

- 因为尽管是最低优先级的中断函数也比普通高优先级任务更重要！
- 所以没必要浪费时间去寻找高优先级的任务。

- 所以在中断函数里，只会唤醒任务，不会去切换。只会在函数最后切换

  <img src="D:\A_Document\Routine_Document\实习\学习\image-20240427194432116.png" alt="image-20240427194432116" style="zoom: 67%;" />

## 两类中断

- 上部中断优先级数值小，且不给用户使用。

- 下部中断优先级数值大，给用户使用，且GPIO/按键/系统时钟中断（systick）属于该类中断

  - SysTick、PenSV默认优先级最低
  - 其他任务（GPIO/按键）可设置

  ![image-20240427204449336](D:\A_Document\Routine_Document\实习\学习\image-20240427204449336.png)

- 关中断：只能关掉下部中断。

![image-20240427200354282](D:\A_Document\Routine_Document\实习\学习\image-20240427200354282.png)

- 在使用中断函数写队列时会出现一下调用

  ![image-20240427200908412](D:\A_Document\Routine_Document\实习\学习\image-20240427200908412.png)

  - 在第中间的函数中，会判断该中断的优先级是否有效（大于阈值，值在高位）：

![image-20240427200749439](D:\A_Document\Routine_Document\实习\学习\image-20240427200749439.png)

## 临界资源的访问方法

![image-20240428145422800](D:\A_Document\Routine_Document\实习\学习\image-20240428145422800.png)



## 普通链表和freeRTOS中的链表区别

- 设置一个list表头，能够挂载结构体。
  - 问题：
    - 对于p1来说,它前面一个是一个`list结构体`
    - 当我们想去使用一个**pre**(`结构体，对该list不同操作时定义的临时结构体变量`)来表示他们前面的成员的时候。
    - 对于这个p2的来说，它的**pre**是一个`person结构体`
    - 这个带来的操作上的不方便

![image-20240428194325231](D:\A_Document\Routine_Document\实习\学习\image-20240428194325231.png)

- 解决：

  - 引入头节点(在list中定义结构体，而非结构体指针)

    struct person *pre = &list->head;

    ![image-20240428195612075](D:\A_Document\Routine_Document\实习\学习\image-20240428195612075.png)

    ![image-20240428195422343](D:\A_Document\Routine_Document\实习\学习\image-20240428195422343.png)

    ​	![image-20240428200407840](D:\A_Document\Routine_Document\实习\学习\image-20240428200407840.png)

    

## 如何解决挂载多种类型结构体？

- 例如：为了实现多种任务挂在就绪链表上

1. 先创建一个通用的node_t结构体，里面就放一个node_t *next成员。
2. 让不同类型结构体中都加入这个node_t类型的结构体

![image-20240428200941701](D:\A_Document\Routine_Document\实习\学习\image-20240428200941701.png)

3. 用node将不同类型节点连接起来（之前同类型结构体，只会记录下一个节点的首地址）
4. 通过减去偏移量（类似-4字节地址）反推结构体首地址，使用结构体。

![image-20240428201149627](D:\A_Document\Routine_Document\实习\学习\image-20240428201149627.png)

#### 如何通过成员节点node找到首地址进而使用该结构体？

1. 创建一个特定类型结构体temp，且设首地址为0；
2. 对temp->node取地址得到偏移量
3. 对个让node类型的地址减去这个偏移量

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240428201952222.png" alt="image-20240428201952222" style="zoom: 50%;" />

![image-20240428203324626](D:\A_Document\Routine_Document\实习\学习\image-20240428203324626.png)

- pre指针转换为char*后加减操作是以字节为单位了，否则以sizeof(struct node_t)为单位i



## 其他三种链接方式

1. 放在最前面，node地址就是结构体地址

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240429200305766.png" alt="image-20240429200305766" style="zoom: 67%;" />

![image-20240429201518061](D:\A_Document\Routine_Document\实习\学习\image-20240429201518061.png)

![image-20240429201656136](D:\A_Document\Routine_Document\实习\学习\image-20240429201656136.png)

2. 前面介绍的反推方法

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240429202226896.png" alt="image-20240429202226896" style="zoom:67%;" />

- 改进：先定义一个宏，用于替换：

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240429202016088.png" alt="image-20240429202016088" style="zoom:67%;" />

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240429202057995.png" alt="image-20240429202057995" style="zoom:67%;" />

3. 在node中增加一个container地址，`保存当前结构体地址`
   - `为什么是void *：因为可以存储任何类型指针`

![image-20240429201021587](D:\A_Document\Routine_Document\实习\学习\image-20240429201021587.png)

![image-20240429202847062](D:\A_Document\Routine_Document\实习\学习\image-20240429202847062.png)

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240429203007459.png" alt="image-20240429203007459" style="zoom:67%;" />

## freeRTOS中的链表

#### 与前面的list-node不同之处：

- node-->item
  - item增加itemValue用来排序
  - 之前container用来存储该链表元素的首地址（拥有者）
  - 现在用pvOwner来存储（比如存储某个TCB的首地址）。
  - 而pxContainer用来存储该item属于哪个list

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240430162658893.png" alt="image-20240430162658893" style="zoom:67%;" />

![image-20240430161438642](D:\A_Document\Routine_Document\实习\学习\image-20240430161438642.png)

- 是双向链表，但与前面的普通双向链表区别：

  ![image-20240430162308183](D:\A_Document\Routine_Document\实习\学习\image-20240430162308183.png)

  - `链表结构体`增加了两个变量，一个表示链表内item个数。另一个是指针，用来遍历当前链表。可以指向当前正在使用的元素。

![image-20240430161209844](D:\A_Document\Routine_Document\实习\学习\image-20240430161209844.png)

#### 新的元素插入在哪

- 插入pxIndex（当前执行位置）之前，而非item3之后

![image-20240430164014025](D:\A_Document\Routine_Document\实习\学习\image-20240430164014025.png)

- 具体代码
- ![image-20240430164501254](D:\A_Document\Routine_Document\实习\学习\image-20240430164501254.png)

#### 空链表如何插入

- pxIndex指向miniListItem
- 新来的元素插入pxindex之前。
  - 空元素情况下
  - pxIndex的previous和next一开始指向自己
  - 接着，previous和next指向新元素
  - 新元素的previous和next指向pxIndex
- 后续在插入节点就与前面的插入方法一样

![image-20240430173057525](D:\A_Document\Routine_Document\实习\学习\image-20240430173057525.png)

## 内存管理

![image-20240430184709501](D:\A_Document\Routine_Document\实习\学习\image-20240430184709501.png)

![image-20240430184740439](D:\A_Document\Routine_Document\实习\学习\image-20240430184740439.png)

### heap1.c

- 在C代码里，定义一个全局数组来当做堆

![image-20240430184825524](D:\A_Document\Routine_Document\实习\学习\image-20240430184825524.png)

- 在代码里如何分配堆：

  1. 对堆数组进行对齐（0x0001->0x0008）
  2. 因为有些芯片不支持这种寻址方式：0x0001+4=0x0005；

  <img src="D:\A_Document\Routine_Document\实习\学习\image-20240430185742534.png" alt="image-20240430185742534" style="zoom:50%;" />

  - 具体的对齐操作：
    - 分配的首地址(0x0001)+指定对齐大小(aligment:8)=0x0009
    - 再与aligment_mask(指定为7，取反) 按位与：
      - 0x0009&~7 = 00....1001 & 11....1000 =00....1000=0x0008
      - 得对齐后地址为0x0008，前面的丢弃

  ![image-20240430190242843](D:\A_Document\Routine_Document\实习\学习\image-20240430190242843.png)

  #### 申请堆后，如何分配给用户空间

  <img src="D:\A_Document\Routine_Document\实习\学习\image-20240430192236114.png" alt="image-20240430192236114" style="zoom: 67%;" />

#### 当用户申请的内存大小不是aligment的整数倍

- 1.计算申请空间大小（向上取整） 
- 2.确定返回值

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240430194443594.png" alt="image-20240430194443594" style="zoom:67%;" />

- 比如申请100字节内存大小

![image-20240430194526803](D:\A_Document\Routine_Document\实习\学习\image-20240430194526803.png)

### heap2.c

#### 背景

- 上述方法没法回收内存vPortFree(p1)，因为它在分配时没有记录给p1分配了多大

![image-20240430201110848](D:\A_Document\Routine_Document\实习\学习\image-20240430201110848.png)

- 解决方法：
  - 申请，分配80+4，用一个头来记录分配长度。

![image-20240430201511410](D:\A_Document\Routine_Document\实习\学习\image-20240430201511410.png)

#### 进一步优化：

- 将堆中空闲的内存块，用链表链接起来，会记录每个块的大小
- 每当用户申请时，遍历链表找到BlockSize>=用户申请内存的块。
- 从链表中删除该块

- ![image-20240430202030322](D:\A_Document\Routine_Document\实习\学习\image-20240430202030322.png)

#### 当链表中的块很大

- 拆分，把剩余空闲的内存在构造一个头记录在空闲链表中

![image-20240430202610802](D:\A_Document\Routine_Document\实习\学习\image-20240430202610802.png)

#### 如何回收呢？

- 把free(p)的块直接插入到链表中
- 问题：`没有合并`内存块，造成内存碎片

![image-20240430202925770](D:\A_Document\Routine_Document\实习\学习\image-20240430202925770.png)

- 但这种heap2的内存管理方式适合`重复申请固定大小的内存`
- ![image-20240430203123084](D:\A_Document\Routine_Document\实习\学习\image-20240430203123084.png)

### heap4.c

- heap2是按照内存块大小排序，而heap4是按照地址排序（有利于合并相邻块）

#### 申请内存

![image-20240502120228361](D:\A_Document\Routine_Document\实习\学习\image-20240502120228361.png)

![image-20240502120301026](D:\A_Document\Routine_Document\实习\学习\image-20240502120301026.png)

#### 释放内存

![image-20240502120745441](D:\A_Document\Routine_Document\实习\学习\image-20240502120745441.png)

![image-20240502121241080](D:\A_Document\Routine_Document\实习\学习\image-20240502121241080.png)

- **判断是否已经插入空闲链表**：

  - 这里应该是malloc出去的时候，freeblock 需要设置为NULL。回收以后如果在freeblock中的话，这个值就指向下一个freeblock ！=NULL

  ![image-20240502121356979](D:\A_Document\Routine_Document\实习\学习\image-20240502121356979.png)

#### 插入链表操作（核心函数）

- 无论是malloc还是free都有
- ![image-20240502122025386](D:\A_Document\Routine_Document\实习\学习\image-20240502122025386.png)
- ![image-20240502121952781](D:\A_Document\Routine_Document\实习\学习\image-20240502121952781.png)
- 其中pxBlockToInsert=pxIterator的意思是**将插入进来的块首地址更新到指向前一个块**

![image-20240502123110039](D:\A_Document\Routine_Document\实习\学习\image-20240502123110039.png)

![image-20240502123212726](D:\A_Document\Routine_Document\实习\学习\image-20240502123212726.png)

### heap5.c

- 前面申请的内存都是连续的一块大数组就够了，但有些内存板子的地址是不连续的，得到的对地址可能是不连续的

  - heap4表示的堆：

  ![image-20240502123858866](D:\A_Document\Routine_Document\实习\学习\image-20240502123858866.png)

  - heap5，用数组存储不连续的内存块

    ![image-20240502124302846](D:\A_Document\Routine_Document\实习\学习\image-20240502124302846.png)

    - 调用初始化对函数后，得到一个链表：
      - 每个堆区内有一个空闲块block（头）、结束块block
      - 结束块xend作为该区的结束位，空闲块块头的Next指向结束块尾部的End，End中的next指向下一个堆区的空闲块。

    ![image-20240502124231923](D:\A_Document\Routine_Document\实习\学习\image-20240502124231923.png)
