# Hot 100

## 哈希

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

```
输入：nums = [2,7,15,11], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

#### 思路

> 遇到num时候，**利用hash表查询**是否遇到过**target-num**

```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> map;
    int len = nums.size();
    for (int i = 0; i < len; i++) {
        auto it = map.find(target - nums[i]); // 查target-num
        if (it != map.end()) return {i, it->second}; // 查到，直接返回
        map[nums[i]] = i; // 没查到，将值保存起来
    }
    return {};
}
```

> 将原数组**排序**。设置头尾指针，**头尾指针的和**如果大于target，尾指针前移。如果小于target，头指针后移，直到找到target。

```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    int len = nums.size();

    vector<pair<int, int>> pairs;
    for (int i = 0; i < len; i++) {
        pairs.push_back(make_pair(nums[i], i)); // 为了排序之后，原数组的下标不丢失，使用pair
    }

    sort(pairs.begin(), pairs.end(),
         [](auto a, auto b) { return a.first > b.first });

    int p = 0, q = len - 1;
    while (p < q) {
        int tmp = pairs[p].first + pairs[q].first;
        if (tmp == target)
            return {pairs[p].second, pairs[q].second};
        else if (tmp > target) // 和大了
            q--;
        else // 和小了
            p++;
    }
    return nums;
}
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

#### 思路

> 关键在于**如何让字母异位词可以对应同一个键**，这样我们就可以通过相同的键将其存放在一起了，如hash表当中。
>
> 一个简单的思路是将字母异位词**排序**。

```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> map;
    for (auto str : strs) {
        string key = str;
        sort(key.begin(), key.end()); // 排序之后键相同
        map[key].emplace_back(str); // 将拥有相同键的词存放进同一个数组当中
    }
    vector<vector<string>> ans;
    for (auto it = map.begin(); it != map.end(); it++) {
        ans.emplace_back(it->second);
    }
    return ans;
}
```

> 排序的复杂度是O(nlogn)，还有一个较为特殊的思路是，将**字符串按字符的数量标准化**。如abaczab，当中有3个a、2个b、一个c和一个z，这可以表示为a3b2c1z1。这样我们就用O(n)的方法找到了一个相同的键。

```cpp
string to_standard(string& str) {
    int chars[26] = {0};
    for (auto& i : str) {
        chars[i - 'a']++; // 统计字符的数量
    }
    string res = "";
    for (int i = 0; i < 26; i++) { // 转为标准字符串
        if (chars[i] != 0) {
            res += 'a' + i;
            res += to_string(chars[i]);
        }
    }
    return res;
}
```

### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

#### 思路

> 最简单的方法是**排序**，但是排序的时间复杂度是O(nlogn)，不满足题目的要求。

```cpp
int longestConsecutive(vector<int>& nums) {
    sort(nums.begin(), nums.end()); // 排序，不满足时间复杂度的要求
    int maxl = 0, len = nums.size();
    int i, j, same;
    for (i = 0; i < len; i++) {
        same = 0;
        for (j = i + 1; j < len; j++) {
            if (nums[j] == nums[j - 1]) {
                same += 1;
            } else if (nums[j] != nums[j - 1] + 1)
                break;
        }
        if (j - i - same > maxl) maxl = j - i - same;
        i = j - 1;
    }
    return maxl;
}
```

> 如果数组当中具有`i、i+1、i+2、i+3`这样的连续序列的时候，我们并不需要从`i+1`之后处理这个序列，因为其前置元素就在数组当中。我们需要处理的是那些**前置元素不在数组当中的元素**。
>
> 所以一个简单的思路是，将数组当中的所有的元素都放入hash表当中。找到那些前置元素不在表中的元素，往后统计其连续序列的长度。

```cpp
int longestConsecutive(vector<int>& nums) {
    if (!nums.size()) return 0;
    unordered_set<int> set;
    for (auto num : nums) { // 将所有元素放入hash表当中
        set.insert(num);
    }
    int cur = 1, max = 1;
    for (auto it = set.begin(); it != set.end(); it++) {
        if (set.count(*it - 1)) continue; // 前置元素在表中，不处理

        cur = 1;
        int next = *it + 1;
        while (set.count(next)) { // 前置元素不在表中，统计其往后的最长连续序列的长度
            cur++;
            next += 1;
        }
        if (cur > max) max = cur; // 更新并记录最大的长度
    }
    return max;
}
```

## 双指针

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

#### 思路

> 如果可以**复制数组**的话，我们可以轻松通过一次遍历复制数组找到所有的非0元素将其放入原数组当中，然后将后面的元素全部赋值为0即可。

```cpp
void moveZeroes(vector<int>& nums) {
    int len = nums.size();
    vector<int> copy(nums);
    int idx = 0;
    for (int i = 0; i < len; ++i)
        if (copy[i]) nums[idx++] = copy[i];
    while (idx < len) nums[idx++] = 0;
}
```

> 可以使用**双指针**的方法。一个指针指向已经处理好的非1元素的后面，另一个指针指向正在处理的元素。
>
> 如果当前正在处理的元素为非0，则两个指针中的元素交换。两个指针同时后移。需要注意的时候，这两个指针中间的元素一定是全部为0的。
>
> `1 2 0(i) 0 0 3(j) 4 0 5` => `1 2 3 0(i) 0 0 4(j) 0 5`

```cpp
void moveZeroes(vector<int>& nums) {
    int len = nums.size();
    if (len < 2) return; // 长度为1，不用处理
    int p = 0, q = 0;
    while (nums[p]) p++; // 先让p找到第一个非1元素
    q = p + 1; // q指向已经维护好的非0元素的后面
    while (q < len) {
        if (nums[q]) swap(nums[p++], nums[q]); // q指向非0，两者交换
        q++;
    }
}
```

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

#### 思路

> 一个**暴力**的想法是，从左到右将数组当中的每一个位置都作为容器的左边界，然后向右遍历找到能使得容量最大的右边界，记录最大容量。算法的时间复杂度为O(n^2)，会超时。

> 一个较为**贪心**的想法是，设置**头尾的双指针**。比较头指针和尾指针的大小。如果头指针更大，则尾指针后移。如果尾指针更大，则头指针后移。
>
> **为什么这样的贪心有效？**双指针其实代表的是可以**作为边界的范围**。初始在两边表示所有的元素都可以作为边界。假定此时头指针小于尾指针，由于**盛水的多少在于短边**。如果以头指针为左边界，因为尾指针只能前移，无论如何盛的水也不会比此时多。因此头指针不能再作为边界，于是头指针后移。

```cpp
int maxArea(vector<int>& height) {
    int len = height.size();
    int max = 0, cur = 0;
    int left = 0, right = len - 1; // 设置头尾指针
    while (left < right) {
        cur = (right - left) * min(height[right], height[left]); // 计算盛水的多少
        if (cur > max) max = cur;
        if (height[left] < height[right]) // 小的边界移动
            left++;
        else
            right--;
    }
    return max;
}
```

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

#### 思路

> `i + j + k = 0`，可以转化为`i + j = -k`这种类型的两数和的问题。所以本题当中的一个最简单的思路就是**固定**一个数，然后将其他的数按照**两数之和**的方式来处理。
>
> 如数组为`-1,0,1,2,-1,-4`，可以固定第一个数`-1`，然后在`0,1,2,-1,-4`中按两数之和的方式寻找和为1的数。但是这样的做法存在这样的问题，如固定`-1`时候，找到了`0，1`和为1，于是将`[-1, 0, 1]`加入数组，然后固定`0`的时候，又找到了`1,-1`，将**重复**的`[0, 1,-1]`加入了数组。
>
> 一个可能的解决方案是将数组排序`[-4,-1,-1,0,1,2]`，然后同样是往后固定。如果发现和前一个要固定的数相同了，则跳过这个数。同理**为了去重**，我们还需要固定第二个数。不能让双指针相向移动，只能让**尾指针不断向前移动**，如果找到一个目标值，立马停止。这样第三个数也不会发生重复。

```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
    int n = nums.size();
    sort(nums.begin(), nums.end()); // 将数组排序，利于去重
    vector<vector<int>> ans;

    for (int first = 0; first < n; first++) {
        // 第一个数之前已经固定过
        if (first > 0 && nums[first] == nums[first - 1]) continue;
        int third = n - 1;
        int target = -nums[first]; // 固定第一个数，寻找两数之和为-first的数
        
        for (int second = first + 1; second < n; second++) {
            // 同样，第二个也要固定，如果重复了直接跳过
            if (second > first + 1 && nums[second] == nums[second - 1]) continue;
            // 第三个数从后面往前面移动
            while (second < third && nums[second] + nums[third] > target) --third;
            // second == third 说明first往后两个最小的元素加起来都比-fisrt小，直接跳过该first
            if (second == third) break; 
            // 找到了目标值
            if (nums[second] + nums[third] == target) 
                ans.push_back({nums[first], nums[second], nums[third]});
        }
    }
    return ans;
}
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

#### 思路

> 我们可以很明显的看出来当一个高度`h[i]`在右面碰到**第一个比他高或一样高**的`h[j]`的时候，他们直接就可以接雨水。倘若i和j之间没有然后高度的话，他们能接的雨水就是，`h[i] * (j - i) * 1`。如果他们中间右一个高度为`h[k]`，很容易得知`h[k] < h[i]`，因为`h[k]`的存在，我们在k位置只能接`h[i] - h[k]`的水。接完水之后，我们需要把接过水的地方补实，防止多余的计算，也就是`h[k]=h[i]`。
>
> 需要注意的是，除了从左到右看，我们还需要从右向左看。如果有高度为`4,2,3`，从左到右看，只有2和3之间能接0的水，但是从右向左看的时候，3和4之间能接1的水。
>
> 处理这种**第一个更大或更小的元素**的时候，我们一般都是使用**单调栈**这个数据结构。单调栈通过维护一个单调递增的序列，来寻找第一个更大的元素。

```cpp
int trap(vector<int>& height) {
    int len = height.size();
    int rain_sum = 0;
    stack<int> st;
    // 从左向右找第一个更大和一样的高度
    for (int i = 0; i < len; ++i) {
        // 比栈顶的元素大
        while (!st.empty() && height[st.top()] <= height[i]) {
            int front = st.top();
            st.pop();
            // 计算front和i之间的雨水
            for (int k = front + 1; k < i; ++k) {
                rain_sum += height[front] - height[k]; // 计算这个位置能接多少雨水
                height[k] = height[front]; // 补实
            }
        }
        st.push(i);
    }
    // 同理，从右向左找
    st = stack<int>();
    for (int i = len - 1; i >= 0; --i) {
        // 比栈顶的元素大
        while (!st.empty() && height[st.top()] <= height[i]) {
            int front = st.top();
            st.pop();
            // 计算front和i之间的雨水
            for (int k = i + 1; k < front; ++k) {
                rain_sum += height[front] - height[k];
                height[k] = height[front];
            }
        }
        st.push(i);
    }
    return rain_sum;
}
```

> 另一种单调栈的解法，只需要一次遍历。由于栈中元素是递减的，当我们遇到一个大于栈顶的元素时，栈顶元素出栈，出栈之后的栈顶元素就是当前接雨水的左边界，当前元素为右边界。

```cpp
int trap(vector<int>& height) {
    int len = height.size();
    int rain_sum = 0;
    stack<int> st;
    for (int i = 0; i < len; ++i) {
        // 比栈顶的元素大
        while (!st.empty() && height[st.top()] < height[i]) {
            int front = st.top();
            st.pop();
            if (st.empty()) break; // 栈为空，接不到雨水，直接break
            int left = st.top(); // 此时栈顶为左边界
            int w = i - left - 1;
            int h = min(height[left], height[i]) - height[front];
            rain_sum += w * h; // 计算能接雨水的多少
        }
        st.push(i);
    }
    return rain_sum;
}
```

> 对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。
>
> 朴素的做法是对每个下标i都向左向右做遍历，时间复杂度为O(n^2)，可以利用**动态规划**的方法将其复杂度降低到O(n)。
> $$
> 1≤i≤n−1，left[i]=max⁡(left[i−1],\ height[i])\\
> 
> 0≤i≤n−2，right[i]=max⁡(right[i+1],\ height[i])
> $$
> 最终在下标i处可以接的雨水就为
> $$
> \min \{left[i],\ right[i]\} - height[i]
> $$

```cpp
// 使用动态规划维护下标i处左右两边的最大的高度
int trap(vector<int>& height) {
    int len = height.size();
    int rain_sum = 0;

    vector<int> left(len, 0);
    vector<int> right(len, 0);
    left[0] = height[0];
    right[len - 1] = height[len - 1];

    for (int i = 1; i < len; ++i) // 计算左边雨水能到达的最大高度(包含自身)
        left[i] = max(left[i - 1], height[i]);
    for (int i = len - 2; i >= 0; --i) // 计算右边雨水能到达的最大高度 (包含自身)
        right[i] = max(right[i + 1], height[i]);

    for (int i = 0; i < len; ++i) 
        rain_sum += min(left[i], right[i]) - height[i]; // 最终该位置能接多少雨水
    

    return rain_sum;
}
```

> 动态规划的做法中，需要维护两个数组 `left`和`right`，可以利用**双指针**将空间复杂度优化到O(n)
>
> 当两个指针没有相遇时，进行如下操作：
>
> 使用 height[left] 和 height[right] 的值更新 left 和 right的值；
>
> 如果 height[left] < height[right]，则必有 left < right，下标 left处能接的雨水量等于 left − height[left]，将下标 left 处能接的雨水量加到能接的雨水总量，然后将 left加 1（即向右移动一位）；
>
> 如果 height[left] ≥ height[right]，则必有 left ≥ right，下标 right处能接的雨水量等于 right − height[right]，将下标 right 处能接的雨水量加到能接的雨水总量，然后将 right减 1（即向左移动一位）
>

```cpp
int trap(vector<int>& height) {
    int len = height.size();
    int rain_sum = 0;
    int left = 0, right = 0;
    int l = 0, r = len - 1;
    while (l < r) {
        left = max(left, height[l]);
        right = max(right, height[r]);
        if (height[l] < height[r]) {
            rain_sum += left - height[l];
            l++;
        } else {
            rain_sum += right - height[r];
            r--;
        }
    }
    return rain_sum;
}
```

## 滑动窗口

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

#### 思路

> 经典的**滑动窗口**问题。维护一个窗口，如果窗内内没有发现重复的字符，则窗口的右边界右移。右移之后如果发现有重复字符，窗口左移知道没有重复字符。以上的判读是否有重复字符和移动到没有重复字符的位置都可以利用**hash表**来优化。由于字符串都是ASCII字符，可以用数组来代替hash表。

```cpp
int lengthOfLongestSubstring(string s) {
    int len = s.size();
    int res = 0;
    // 存放上一次看到的字符的位置，由于是ASCII字符可以用数组代替hash表
    vector<int> hash(128, -1);
    int left = 0;
    for (int i = 0; i < len; ++i) {
        // 窗口当中已经有这个字符了
        if (hash[s[i]] >= left) {
            // 不重复的窗口为 [left, i)
            res = max(res, i - left);
            // 移动窗口到重复字符的下一个位置
            left = hash[s[i]] + 1;
        }
        // 保存位置
        hash[s[i]] = i;
    }
    res = max(res, len - left);
    return res;
}
```

### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

#### 思路

> 维护一个窗口，窗口内的字符都是组成p的一部分。**窗口中的字符+p当前的字符=原先p的字符**
>
> - 如果**窗口右侧的字符c在p中当前还存在**，窗口右移，p中字符c的数量减1。
>
> - 如果发现窗口右侧的字符在c中**本来就不存在**，则窗口的左侧直接移动到c的下一个位置。
>
> - 如果是**本来存在**，由于窗口的原因**使用完了当前不存在**，那么窗口的左侧移动到第一次碰到c的下一个位置，窗口右侧向后移动。
>
> 如果发现窗口的大小等于p的大小了，则就是发现了一个异位词。

```cpp
#define Int(x) x - 'a'
class Solution {
   public:
    // abaacbabc abc
    vector<int> findAnagrams(string s, string p) {
        int len = s.size(), sublen = p.size();
        vector<int> res;
        int map[26] = {0};
        for (int i = 0; i < sublen; i++) map[Int(p[i])]++;

        int start = 0, r = 0;
        while (r < len) {
            if (map[Int(s[r])]) { // r字符在当前的p中
                map[Int(s[r])]--; // p中r字符的数量减少
                if (r - start + 1 == sublen) res.push_back(start); // 窗口的长度和原p长度一样
                r++; // 窗口右移
            } else {
                while (start < r) { // 窗口尝试吐出一些字符看看能不能满足r在当前的p中
                    map[Int(s[start])]++;
                    if (s[start++] == s[r]) break;
                }
                if (!map[Int(s[r])]) {  // 这说明原字符串当中就没有r字符
                    start = ++r; // 窗口和左面直接移动到r的右侧
                }
                // 如果原字符串当中有r字符，窗口是不需要右移的嗷
            }
        }
        return res;
    }
};
```

## 子串

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

```
输入：nums = [1,1,1], k = 2
输出：2
```

#### 思路

> 这是一个典型的**子区间求和**的问题，碰到子区间求和问题的时候，一般都会采用**前缀和**。
> $$
> sum[i,j) = sum[0,j) - sum(0,i)
> $$
>
>通过hash表存储前缀和，检查之前遇到几次k减去当前的前缀和即可。

```cpp
int subarraySum(vector<int>& nums, int k) {
    int len = nums.size();
    int cot = 0;
    unordered_map<int, int> map;
    map[0] = 1;
    int sum = 0;
    for (int i = 0; i < len; i++) {
        sum += nums[i];
        cot += map[sum - k];
        map[sum]++;
    }
    return cot;
}
```

### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。返回 *滑动窗口中的最大值* 。

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
```
#### 思路
> 一个简单的想法是**每次遍历整个窗口**找到窗口当中的最大值，但是这样复杂度太高，不难看出，窗口**每次移动只有一个元素**发生了变化。我们可以利用**最大堆来维护这个最大值**，窗口移动的时候将新值放入堆中，然后此时的最大值不一定是窗口当中的元素，我们只需要在放入最大堆的时候**同时标记其位置**即可，遇到不在当前窗口当中的元素直接弹出即可。

```cpp
typedef pair<int, int> PII;
class Solution {
   public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int len = nums.size();
        vector<int> res;
        if (len < k) return res;
        priority_queue<PII> p;
        for (int i = 0; i < k; ++i) p.push({nums[i], i});
        res.push_back(p.top().first);

        for (int i = k; i < nums.size(); ++i) {
            p.push({nums[i], i});
            auto [val, idx] = p.top();
            while (idx < i - k + 1) {
                p.pop();
                val = p.top().first, idx = p.top().second;
            }
            res.push_back(val);
        }
        return res;
    }
};
```

> 此题最好的解法是使用**单调队列**。单调队列比较适合去查询**滑动窗口类型的区间的最大/小值**问题。求滑动窗口的最大值，我们可以构造一个递减的单调队列。如`1,3,-1,-3`，由于3在1的后面入队，而3又大于1，所以1无论如何也无法成为区间的最大值可以直接出队。
>
> 构建单调队列的时候每次遇到新元素的时候，都**让其与队尾元素**相比较，如果其比队尾元素大，队尾元素出队，直到队尾元素比该元素大或队列为空。

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    int n = nums.size();
    deque<int> q;
    for (int i = 0; i < k; ++i) {
        // 比nums[i]小的没有机会称为最大元素，直接从队尾出队
        while (!q.empty() && nums[i] >= nums[q.back()]) { 
            q.pop_back();
        }
        q.push_back(i);
    }
	// 队首元素为最大元素，队尾元素为最小元素
    vector<int> ans = {nums[q.front()]};
    for (int i = k; i < n; ++i) {
        // 比nums[i]小的没有机会称为最大元素，直接从队尾出队
        while (!q.empty() && nums[i] >= nums[q.back()]) {
            q.pop_back();
        }
        q.push_back(i);
        // 队首元素不在窗口内，从队首出队
        while (q.front() <= i - k) {
            q.pop_front();
        }
        // 在窗口内的队首元素就是该窗口的最大元素
        ans.push_back(nums[q.front()]);
    }
    return ans;
}
```

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```
#### 思路
> 简单的**滑动窗口**题型。我们维护一个窗口，当窗口中的字符**不包含t中的所有的字符**的时候，窗口右移。当窗口**包含t中的所有的字符**的时候，窗口逐渐左移，直到下一次移动将不会包含t中的所有的字符。可以使用hash表来记录窗口当中的字符数。

```cpp
class Solution {
   public:
    string minWindow(string s, string t) {
        int lens = s.size(), lent = t.size();
        if (lent > lens) return "";
        vector<int> hash(128, 0); // 需要多少个字符组成t
        vector<bool> has(128); // t中是否有某个字符
        for (int i = 0; i < lent; ++i) {
            hash[t[i]]++;
            has[t[i]] = true;
        }

        int left = 0, start = -1, min_val = 0x7fffffff;
        for (int i = 0; i < lens; ++i) {
            if (has[s[i]]) { // t中有该字符才处理，没有的话窗口无脑右移
                hash[s[i]]--; // 满足一个需求
                if (allZero(hash)) { // 窗口当中是否包含了t所需的所有的字符，即hash当中均小于等于0
                    while (left < i) {
                        if (!has[s[left]]) // 不是t需要的字符可以舍弃
                            left++;
                        else if (hash[s[left]] < 0) { // 是t需要的，但是多余了也可以舍弃
                            hash[s[left]]++;
                            left++;
                        } else // 遇到了不可舍弃的字符
                            break;
                    }
                    if (i - left + 1 < min_val) { // 更新结果
                        min_val = i - left + 1;
                        start = left;
                    }
                }
            }
        }
        if (start == -1) return ""; // 没找到的话返回空字符串
        return s.substr(start, min_val);
    }

   private:
    bool allZero(vector<int>& nums) { // 颜值数组当中的所有元素是否均小于等于0
        int len = nums.size();
        for (int i = 'A'; i <= 'Z'; ++i) {
            if (nums[i] > 0) return false;
        }
        for (int i = 'a'; i <= 'z'; ++i) {
            if (nums[i] > 0) return false;
        }
        return true;
    }
};
```

## 普通数组

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```
#### 思路
> 这是一个连续区间和的问题，第一反应可以想到使用**前缀和**来做。我们**保存最小的前缀和**，使用当前前缀和减去最小的前缀和就是以当前元素为右边界的最大的区间和。

```cpp
int maxSubArray(vector<int>& nums) {
    int len = nums.size();
    int sum = 0, min_sum = 0, max_sum = nums[0];
    for (int i = 0; i < len; ++i) {
        sum += nums[i]; // 计算当前的前缀和
        max_sum = max(max_sum, sum - min_sum); // 减去之前的最小的前缀和
        min_sum = min(sum, min_sum); // 更新最小的前缀和
    }
    return max_sum;
}
```

> 还有一种也容易想到的方法是动态规划。我们设`dp[i]`代表以i位置为结尾的最大连续的子数组的和，则有
> $$
> dp[i] = \max\{dp[i-1]+num[i],num[i]\}
> $$
> 由于i状态只和i-1状态有关，我们也可以进行dp数组的**状态压缩**

```cpp
int maxSubArray(vector<int>& nums) {
    int len = nums.size();
    int sum = 0, max_sum = nums[0];
    for (int i = 0; i < len; ++i) {
        sum = max(sum + nums[i], nums[i]); // dp[i] = max{dp[i-1]+num[i],num[i]}
        max_sum = max(sum, max_sum); // 更新最大值
    }
    return max_sum;
}
```

### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

#### 思路

> 很容易看出来的贪心的思路。将原数组**按左端点进行排序**，如果一个区间的左端点小于等于上一个区间的右端点，则这两个区间就可以合并，将右端点更新即可。当左端点大于上一个区间的右端点的时候，不能合并，输出上一个区间即可。

```cpp
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    int len = intervals.size();
    vector<vector<int>> res;

    sort(intervals.begin(), intervals.end()); // 按左端点进行排序

    int left = intervals[0][0], right = intervals[0][1];
    for (int i = 1; i < len; i++) {
        if (intervals[i][0] <= right) // 可以合并
            right = max(right, intervals[i][1]); // 更新右端点
        else {
            res.push_back({left, right}); // 不能合并输出上一个区间
            left = intervals[i][0]; // 将这个区间作为新的区间
            right = intervals[i][1];
        }
    }
    res.push_back({left, right}); // 不要忘记最后一个区间的输出
    return res;
}
```

### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

#### 思路

> 最简单的想法就是使用**额外的空间**。

```cpp
void rotate(vector<int>& nums, int k) {
    vector<int> tmp = nums;
    int len = nums.size();
    k = k % len; // 注意：k可能会很大，要先取模
    for (int i = 0; i < len; ++i) {
        nums[i] = tmp[(i + len - k) % len];
    }
}
```

> 还有一个容易理解并且不需要额外空间的算法，那就是**使用翻转来实现数组的轮转**。如将1234567右移三步，可以先翻转前4个变成4321567，再翻转后三个变成4321765，再翻转整个数组变成5671234。

```cpp
void rotate(vector<int>& nums, int k) { // 调用API实现三次翻转即可
    k = k % nums.size();
    reverse(nums.begin(), nums.end());
    reverse(nums.begin(), nums.begin() + k);
    reverse(nums.begin() + k, nums.end());
}
```

### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

#### 思路

> 使用除法自然很简单，数组中如果有多个0，那么就都是0。如果有一个0，那么0处是非零元素的积，非零处是0。如果数组当中没有零，计算所有元素的积，然后除以元素自身就可以得到答案了。

```cpp
vector<int> productExceptSelf(vector<int>& nums) {
    int len = nums.size();
    long long mul = 1; // 使用long long保存防止溢出
    int zero_count = 0;
    int zero_index = -1;
    for (int i = 0; i < len; i++) {
        if (nums[i])
            mul *= nums[i];
        else {
            zero_count++;
            zero_index = i;
        }
    }
    if (zero_count > 1) {
        fill(nums.begin(), nums.end(), 0);
    } else if (zero_count == 1) {
        fill(nums.begin(), nums.end(), 0);
        nums[zero_index] = mul;
    } else {
        for (int i = 0; i < len; i++) nums[i] = mul / nums[i];
    }
    return nums;
}
```

> 不考虑除法，这种**除自身以外的和/积问题**，一般使用**前缀和后缀**来解决。因为前缀和后缀的计算复杂度较低，我们计算每一个位置的前面的所有的元素的积，和后面的所有的元素的积，那么答案就是这两个积的积了。

```cpp
vector<int> productExceptSelf(vector<int>& nums) {
    int len = nums.size();
    // 如果存储了后缀，我们可以在计算前缀的同时计算结果，所以没必要将前缀存放进数组
    vector<int> suffix(len); 
    vector<int> res(len);

    int sfix = 1, pfix = 1;
    for (int i = len - 1; i >= 0; --i) {
        suffix[i] = sfix;
        sfix *= nums[i];
    }
    for (int i = 0; i < len; ++i) {
        res[i] = pfix * suffix[i];
        pfix *= nums[i];
    }
    return res;
}
```

### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

```
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
```

> 数组的长度为n，那么结果肯定是**在1到n+1当中**，最简单的方法就是利用一**个O(n)的空间**来标记遇到了哪些1到n+1之间的数。然后从小到大遍历，得到没遇到的最小的正数。

```cpp
int firstMissingPositive(vector<int>& nums) {
    int len = nums.size();
    vector<bool> tmp(len + 2, false);

    for (int i = 0; i < len; ++i)
        if (nums[i] <= len && nums[i] >= 1) tmp[nums[i]] = true;

    for (int i = 1; i <= len + 1; ++i)
        if (tmp[i]) return i;
    return 0;
}
```

> 为了处理负数，先将数组当中所有的负数变成N+1。然后遇到X之后就给X-1的位置打上负数标记。之后遍历第一个没有打上标记的数组即可。

```cpp
int firstMissingPositive(vector<int>& nums) {
    int len = nums.size();
    for (int i = 0; i < len; ++i) // 小于0处理为len+1
        if (nums[i] <= 0) nums[i] = len + 1;

    for (int i = 0; i < len; ++i) {
        int tmp = abs(nums[i]);
        if (tmp <= len) nums[tmp] = -abs(nums[tmp]); // 把负数当作是标记
    }

    for (int i = 0; i < len; ++i) {
        if (nums[i] > 0) return i + 1; // i是正数说明没有标记，即没有遇到i+1这个数
    }
    return len + 1; // 说明都遇到了，nums就是[1...len]的序列，返回len+1即可
}
```

## 矩阵

### [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法。

```
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

#### 思路

> 最简单的思路就是**存储有0的行号和列号**，空间也就O(m+n)。

```cpp
void setZeroes(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    vector<bool> hasZeroM(m, 0), hasZeroN(n, 0);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (!matrix[i][j]) { // 存放为0的行号和列号
                hasZeroM[i] = true;
                hasZeroN[j] = true;
            }
        }
    }

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (hasZeroM[i] || hasZeroN[j]) {
                matrix[i][j] = 0;
            }
        }
    }
}
```

> 原地算法**使用第一行和第一列来代替上面的两个数组**来存放有0的行号和列号的信息，但是这样**丢失了**原来的第一行和第一列是否有0的信息，所以需要两个**额外的变量**来记录。

```cpp
void setZeroes(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    bool row0 = false, col0 = false; 
    for (int i = 0; i < m; ++i) // 记录第一列是否有0
        if (!matrix[i][0]) col0 = true;
    for (int i = 0; i < n; ++i) // 记录第一行是否有0
        if (!matrix[0][i]) row0 = true;
    for (int i = 1; i < m; i++) { // 根据0的位置将其对应的第一行和第一列的元素置0
        for (int j = 1; j < n; j++) {
            if (!matrix[i][j]) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) { // 根据第一行和第一列当中的0置0
            if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;
        }
    }
    if (col0) // 如果本来第一列有0，将第一列所有的元素置0
        for (int i = 0; i < m; ++i) matrix[i][0] = 0;
    if (row0) // 第一行也是同理
        for (int i = 0; i < n; ++i) matrix[0][i] = 0;
}
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 <img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img" style="zoom: 50%;" />

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

#### 思路

> 可以直接用**模拟**的思路去做。按照右下左上这四个方向走，每次**遇到边界或者访问过的元素就换个方向**。

```cpp
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    vector<int> res;

    int vis[12][12] = {0}; // 将边界都设置为已访问，简化下边的判读
    for (int i = 0; i <= m; i++) {
        vis[i][0] = 1;
        vis[i][n + 1] = 1;
    }
    for (int i = 0; i <= n; i++) {
        vis[0][i] = 1;
        vis[m + 1][i] = 1;
    }

    int dx[4] = {0, 1, 0, -1}; // 定义四个方向
    int dy[4] = {1, 0, -1, 0};
    int dir = 0; // 当前的方向

    int x = 1, y = 1;
    while (true) {
        res.push_back(matrix[x - 1][y - 1]); // 加入结果当中
        vis[x][y] = 1; // 标记为已访问
        if (res.size() == m * n) break; // 已访问完所有的元素

        int nextx = x + dx[dir];
        int nexty = y + dy[dir];
        if (vis[nextx][nexty]) { // 再走要碰到已访问过的元素，换一个方向
            dir = (dir + 1) % 4;
            nextx = x + dx[dir];
            nexty = y + dy[dir];
        }
        x = nextx;
        y = nexty;
    }

    return res;
}
```

### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

 <img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img" style="zoom:50%;" />

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```
#### 思路

> 顺时针旋转90度就是把原图当中的`(i,j)`位置的元素变换到`(j,n-i-1)`的位置上去。我们可以用**两次对称**来模拟这个变换，首先先**按照主对角线对称**将`(i,j)`变换到`(j,i)`，然后再按照中间的列左右对称将`(j,i)`变换到`(j,n-i-1)`即可。

```cpp
void rotate(vector<vector<int>>& matrix) {
    int n = matrix.size();
    for (int i = 0; i < n; i++) { // 按照主对角线对称
        for (int j = 0; j < i; j++) swap(matrix[i][j], matrix[j][i]);
    }

    for (int i = 0; i < n / 2; i++) { // 按照中间的列左右对称
        for (int j = 0; j < n; j++)
            swap(matrix[j][i], matrix[j][n - i - 1]);
    }
}
```

### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt="img" style="zoom:50%;" />

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

#### 思路

> 不难发现矩阵的**每一行或每一列都是有序**的，所以我们可以对矩阵的行或者列进行**n次的二分搜索**。

```cpp
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size(), n = matrix[0].size();
    for (int i = 0; i < m; i++) { // 对矩阵的每一行进行二分搜索
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            int val = matrix[i][mid];
            if (val == target)
                return true;
            else if (val > target)
                right = mid - 1;
            else
                left = mid + 1;
        }
    }
    return false;
}
```

> 我们注意到**矩阵的右上角**是一个特殊的位置，其左边的元素都比自己小，其下面的元素都比自己大。我们可以利用这个特性进行**Z字搜索**，即从右上角向左下角搜索。初始将搜索点放在右上角，如果其比目标元素大，则左移；如果其比目标元素小，则下移；直到搜索到目标返回。

```cpp
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size(), n = matrix[0].size();
    int x = 0, y = n - 1; // 从右上角开始搜索
    while (x < m && y >= 0) {
        if (matrix[x][y] == target)
            return true;
        else if (matrix[x][y] > target) // 比目标值大，左移，相等于淘汰了其下面的更大的元素
            y--;
        else // 比目标值大，下移，相等于淘汰了其左面的更小的元素
            x++;
    }
    return false; // 没搜到
}
```

## 链表

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" style="zoom: 67%;" />](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

#### 思路

> 最简单的思路就是使用**hash表保存链表A和B遍历过的结点**，如果发现hash表**有重复的结点**的话，返回该结点即可。

```cpp
class Solution {
   public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode *> node_set;
        ListNode *p = headA;
        while (p) {
            node_set.insert(p);
            p = p->next;
        }
        p = headB;
        while (p) {
            if (node_set.count(p)) return p;
            p = p->next;
        }
        return nullptr;
    }
};
```

> 还有一种思路也非常的直观，如果链表在某一个点相遇，那么他们后面的结点一定是一样长的。我们可以**先算出两个链表的长度**，然后让**长的链表先走几步使其剩余长度和短的一致**，然后再让两个链表**同时行动**。这样如果他们有公共的结点，一定会同时遇见。

```cpp
class Solution {
   public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA = getLen(headA), lenB = getLen(headB);
        if (lenA > lenB) // 长的先走几步
            for (int i = 0; i < lenA - lenB; i++) headA = headA->next;
        if (lenA < lenB)
            for (int i = 0; i < lenB - lenA; i++) headB = headB->next;

        while (headA) { // 两个链表同时走
            if (headA == headB) return headA; // 碰到了公共结点了
            headA = headA->next;
            headB = headB->next;
        }
        return nullptr;
    }

   private:
    int getLen(ListNode *head) { // 计算链表的长度
        int n = 0;
        while (head) {
            head = head->next;
            n++;
        }
        return n;
    }
};
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

<img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

#### 思路

> 最简单的思路就是运用**递归**来做。反转`head`可以利用反转`head->next`这个子问题。

```cpp
ListNode* reverseList(ListNode* head) {
    if (!head || !head->next) return head; // 递归终止条件，右侧没有结点直接返回
    ListNode* rHead = reverseList(head->next); // head右侧结点反转之后的链表
    head->next->next = head; // head的后一个节点指向head
    head->next = nullptr; // head此时是最后一个节点，要指向nullptr，不然就产生环了
    return rHead; // 返回的是右侧反转链表之后的头
}
```

> 当然不用递归**直接原地反转**也是可以的，`p->q->t`，可以先将`q`指向`p`也就是`p<-q->t`，然后再将`p`移到到`q`处，`q`移动到`t`处重复这个操作。

```cpp
ListNode* reverseList(ListNode* head) {
    if (!head) return head;
    ListNode *cur = head, *next = head->next, *prev = nullptr;
    while (cur) {
        cur->next = prev; // 当前结点指向前一个结点
        prev = cur; // 前一个移动到当前
        if (!next) return cur; // 没有下一个结点了，直接返回当前的结点
        cur = next; // 当前结点移动到下一个结点
        next = next->next; // 下一个结点也移动到下一个结点
    }
    return nullptr;
}
```

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false`。

![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

#### 思路

> 最简单的思路就是将链表当中的元素**放入到数组当中去**，然后判读这个数组是否是回文的就很简单了。

```cpp
bool isPalindrome(ListNode *head) {
    vector<int> nums;
    while (head) { // 链表元素放入数组当中
        nums.push_back(head->val);
        head = head->next;
    }
    int l = 0, r = nums.size() - 1;
    while (l < r) { // 判读数组是否是回文的
        if (nums[l] != nums[r]) return false;
        ++l, --r;
    }

    return true;
}
```

> 想要避免使用O(n)的空间，就需要改变输入的链表。我们使用**快慢指针找到链表的中点**，然后将链表**中点之后的链表反转**，然后和前半部分的链表进行比较即可。

```cpp
class Solution {
   public:
    bool isPalindrome(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while (fast->next && fast->next->next) {  // 确保fast还有两格可以跳
            fast = fast->next->next;
            slow = slow->next;
        }
        // 链表长度奇数，slow在中点，链表长度偶数，slow在前半的最后一个
        // 总之，slow的下一个结点就是后半部分的开始
        ListNode *rhead = reverseList(slow->next);
        while (rhead && head) {
            if (head->val != rhead->val) return false;
            head = head->next;
            rhead = rhead->next;
        }
        return true;
    }

   private:
    ListNode *reverseList(ListNode *head) { // 上面的翻转链表
        if (!head) return head;
        ListNode *cur = head, *next = head->next, *prev = nullptr;
        while (cur) {
            cur->next = prev;
            prev = cur;
            if (!next) return cur;
            cur = next;
            next = next->next;
        }
    }
};
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

给你一个链表的头节点 `head` ，判断链表中是否有环。

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:50%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

#### 思路

> 非常典型的问题，最直接最容易想到的就是使用**hash表判重**，如果遇到重复的结点就是链表有环。

```cpp
bool hasCycle(ListNode *head) {
    unordered_set<ListNode *> node_set;
    while (head) {
        if (node_set.count(head)) return true;
        node_set.insert(head);
        head = head->next;
    }
    return false;
}
```

> 有个更应该掌握的方法是，**使用快慢指针来判环**。如果链表有环，那么**快慢指针一定会相遇**。

```cpp
bool hasCycle(ListNode *head) {
    ListNode *slow = head, *fast = head; // 快慢指针
    while (slow && fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

<img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:50%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

#### 思路

> 上面的第一种方法判断环的位置很简单，直接返回就可以了

```cpp
ListNode *detectCycle(ListNode *head) {
    unordered_set<ListNode *> node_set;
    while (head) {
        if (node_set.count(head)) return head;
        node_set.insert(head);
        head = head->next;
    }
    return nullptr;
}
```

> **快慢指针**相遇的位置并不是环的位置。假设环之前的长度为A，环的长度为B，慢指针超过环的长度为C，慢指针走过的长度为N，初始点到环的入口的距离则为A。因为快慢指针相遇时是快指针**超过了一圈环长度**，则有`N = A + C; 2N - N = B`即：`A = C - B`，也就是说此时把**快指针放在开始的位置**，速度也改成一次移动一格，和慢指针**同时移动**，那么他们**相遇**的那个结点就是环的入口。

```cpp
ListNode *detectCycle(ListNode *head) {
    ListNode *slow = head, *fast = head;
    while (slow && fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) { // 快慢指针相遇
            fast = head; // 快指针移动到头部
            while (slow != fast) { // 两个指针同时慢速移动直到相遇
                slow = slow->next;
                fast = fast->next;
            }
            return slow; // 相遇的地方就是环的入口
        }
    }
    return nullptr;
}
```

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

<img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img" style="zoom:50%;" />

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

#### 思路

> 每次在两个链表当中**挑选小的结点放到新的链表**当中即可，如果一个链表当中的元素全部放完，则直接将另一个链表的剩余元素都放到新链表的最后即可。

```cpp
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    // 因为不知道使用list1还是list2作为头，所以创建一个新的空节点暂时作为头节点
    ListNode *head = new ListNode(0), *p = head; 
    while (list1 && list2) {
        if (list1->val < list2->val) { // 取更小的结点放入链表当中
            p->next = list1;
            p = p->next;
            list1 = list1->next;
        } else {
            p->next = list2;
            p = p->next;
            list2 = list2->next;
        }
    }
    if (list1)
        p->next = list1;
    else if (list2)
        p->next = list2;
    return head->next; // 返回头结点的next
}
```

> 本题也是可以用**递归**做的，更加易懂，但是毕竟递归比较占用栈空间，这种不递归也很简单的问题能不递归就不递归吧。

```cpp
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1) return list2;
    if (!list2) return list1;
    if (list1->val < list2->val) {
        ListNode* nhead = mergeTwoLists(list1->next, list2);
        list1->next = nhead;
        return list1;
    } else {
        ListNode* nhead = mergeTwoLists(list1, list2->next);
        list2->next = nhead;
        return list2;
    }
}
```

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。



<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img" style="zoom:50%;" />

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

### 思路

> 因为是按照逆序存储的，所以本题我们不需要对链表进行翻转处理。我们自己利用处理**高精度**数组的方式来处理这个链表就行了。

```cpp
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode *p = l1, *q = l2, *head = nullptr, *t = nullptr;
    int jw = 0; // 类似高精度，先设置进位
    while (p || q) {
        int pval = 0, qval = 0;
        if (p) {
            pval = p->val;
            p = p->next;
        }
        if (q) {
            qval = q->val;
            q = q->next;
        }
        int sum = pval + qval + jw; // 求和
        jw = sum / 10; // 更新进位
        if (t) {
            t->next = new ListNode(sum % 10); // 值设置为模
            t = t->next;
        } else {
            t = new ListNode(sum % 10);
            head = t;
        }
    }
    if (jw) { // 还有一个最高位的进位需要处理
        t->next = new ListNode(jw);
    }
    return head;
}
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

<img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

#### 思路

> 最简单的方法就是先求链表的长度`len`，然后计算这个节点是正数的第`len-n`个节点，删除即可。

```cpp
ListNode* removeNthFromEnd(ListNode* head, int n) {
    int len = 0;
    ListNode *p = head, *q = head;
    while (p) ++len, p = p->next; // 计算长度
    if (n > len) return head; // 没有这个倒数
    if (n == len) return head->next; // 删除第一个
    for (int i = 0; i < len - n - 1; ++i) q = q->next; // 找到前一个结点
    q->next = q->next->next; // 删除
    return head;
}
```

> 还有一个更好的思路是，**先让一个指针先走**`n`步，然后再让一个指针从起点开始走，当先走的指针**到达终点**时，后走的指针就在倒数第k个节点处。

```cpp
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode *p = head, *q = head;
    for (int i = 0; i < n; i++) { // 让一个指针先走n步
        p = p->next;
    }
    if (!p) return head->next; // 刚好走到终点，即删除第一个结点
    p = p->next; // 再走一步是为了让后走的指针到倒数第k+1个结点，这样才好删除倒数第k个
    while (p) {
        p = p->next;
        q = q->next;
    }
    q->next = q->next->next;
    return head;
}
```

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

<img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

> 使用**迭代**的方法和链表翻转的思路基本是相同的

```cpp
ListNode* swapPairs(ListNode* head) {
    ListNode *nhead = new ListNode(0), *p = nhead; // 新建一个空头节点利于操作
    nhead->next = head;
    while (p->next && p->next->next) { // 有两个结点可以用来交换
        ListNode *node1 = p->next, *node2 = p->next->next; // 记录这两个结点
        p->next = node2; // 头指向第二个结点
        node1->next = node2->next; // 第一个节点的后面指向第二个结点的后面
        node2->next = node1; // 第二个结点后面指向第一个节点
        p = node1; // 指向第一个节点，即继续看第一个节点之后是否有两个结点可以交换
    }
    ListNode* tmp = nhead->next;
    delete nhead;
    return tmp;
}
```

> 使用**递归**的方式应该是更容易理解的

```cpp
ListNode* swapPairs(ListNode* head) {
    if (!head || !head->next) return head; // 没有两个结点直接返回
    ListNode *node1 = head, *node2 = head->next; // 记录这两个结点
    ListNode* rhead = swapPairs(node2->next); // 将两个结点后面的链表也进行交换
    node2->next = node1; // 第二个结点指向第一个结点
    node1->next = rhead; // 第一个结点指向后面交换完了的链表
    return node2; // 此时头结点是原先的第二个结点
}
```

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

<img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

#### 思路

> 本题用**递归**的话，还是蛮好做的。和普通的翻转链表没啥本质的区别。

```cpp
class Solution {
   public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (!head || !head->next) return head;
        ListNode* p = head;
        for (int i = 0; i < k - 1; ++i) {
            p = p->next;
            if (!p) return head;
        }
        ListNode* q = p->next;
        p->next = nullptr;
        ListNode* lhead = reverse(head);
        head->next = reverseKGroup(q, k);
        return lhead;
    }

   private:
    ListNode* reverse(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode* rhead = reverse(head->next);
        head->next->next = head;
        head->next = nullptr;
        return rhead;
    }
};
```

> 如果不使用递归，只使用**迭代**的解法的话。过于**复杂繁琐**，这里不再提供。

### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

#### 思路

> 使用使用一个**hash表**来建立复制之前的结点和复制之后的结点的**联系**。先不考虑random指针复制整个链表并建立结点的联系，然后遍历一次，通过random指向的原始结点映射到复制的结点即可。

```cpp
Node* copyRandomList(Node* head) {
    if (!head) return head;
    unordered_map<Node*, Node*> map; // 建立结点之前的联系
    Node *newHead = nullptr, *p = nullptr;

    p = new Node(head->val); // 先建立复制结点的头节点
    p->next = head->next;
    p->random = head->random;
    map.insert({head, p}); 
    newHead = p;
    head = head->next;

    while (head) {
        p->next = new Node(head->val);
        p = p->next;
        p->next = nullptr;
        p->random = head->random; // 先就直接复制random指针
        map.insert({head, p}); // 建立结点直接的联系
        head = head->next;
    }
    p = newHead;
    while (p) {
        p->random = map[p->random]; // 通过之前建立的联系将random指针修改为复制之后的
        p = p->next;
    }
    return newHead;
}
```

### [148. 排序链表](https://leetcode.cn/problems/sort-list/)

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

<img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

#### 思路

> 首先最容易想到的排序思路就是**冒泡排序**了，不断的将大节点往后移，符合链表的操作思路。但是冒泡排序的**复杂度较高**，很多测试用例都会TLE。


```cpp
ListNode *sortList(ListNode *head) {
    if (!head || !head->next) return head;
    List p = head, q = nullptr, e = nullptr, prev = nullptr;
    while (p && p->next != e) {
        q = p->next;
        while (q != e) {
            if (p->val > q->val) swap(q->val, p->val);
            p = p->next;
            prev = q;
            q = q->next;
        }
        e = prev;
        p = head;
    }
    return head;
}
```


> 注意到对两个**有序的链表进行合并**是简单的，并且链表本身就是一个**适合递归**的结果，所以我们不难想到使用**归并排序**的方式。归并排序当中还有一个重要的**找中点**的过程，我们可以使用**快慢指针**的方式快速找到链表的中点，将链表一分为二。

```cpp
// 将这个链表排好序
ListNode* merge_sort(ListNode* head) {
      if (head == nullptr || head->next == nullptr) { // 递归的终止条件
        return head;
      }	
      // 链表寻找中间点一般都是使用快慢指针的方式
      ListNode* slow = head, *fast = head->next;
      while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
      }
      // 切断左右两个链表
      ListNode* mid = slow->next;
      slow->next = nullptr; 
      // 将左右链表分别排好序
      left = merge_sort(head);
      right = merge_sort(mid);
      // 将两个有序链表合并成为一个有序链表，这个题目之前做过
      return merge(left, right);
}
```

### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

#### 思路

> 最简单的做法就是将有序的链表**两两合并**直到数组当中只有一个链表了。不过比较出乎意外的是，这种暴力的做法都可以通过本题的所有测试用例。

```cpp
typedef ListNode* List;
class Solution {
   public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int len = lists.size();
        if (!len) return nullptr;
        List a = lists[0], b;
        for (int i = 1; i < len; ++i) { // 将数组两两合并
            b = lists[i];
            a = merge2Lists(a, b);
        }
        return a;
    }

   private:
    ListNode* merge2Lists(ListNode* l1, ListNode* l2) { // 合并两个有序的链表
        if (!l1) return l2;
        if (!l2) return l1;
        if (l1->val < l2->val) {
            l1->next = merge2Lists(l1->next, l2);
            return l1;
        } else {
            l2->next = merge2Lists(l1, l2->next);
            return l2;
        }
    }
};
```

> 考虑到使用上面的那种合并的思路的话，a链表会变得太长，影响了合并的效率。所以对上面合并方式的改进就是，先两两合并8个合并成4个，然后再两两合并，4个合并成2个。这样我们可以尽可能的**让每次合并的链表长度都差不多**。可以看出这个思路就有点像**归并排序**的思路了。

```cpp
typedef ListNode* List;
class Solution {
   public:
    // 利用了归并排序的思路
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return mergeKListsHelper(lists, 0, lists.size() - 1);
    }
   private:
    // 将数组当中的链表看作是一个数字，使用归并排序。
    List mergeKListsHelper(vector<List>& lists, int left, int right) {
        if (left == right) return lists[left];
        if (left > right) return nullptr;
        int mid = left + ((right - left) >> 1);
        List l1 = mergeKListsHelper(lists, left, mid); // 左半合并成一个链表
        List l2 = mergeKListsHelper(lists, mid + 1, right); // 右半也合并成一个链表
        return merge2Lists(l1, l2); // 将这两个有序的链表合并
    }
    ListNode* merge2Lists(ListNode* l1, ListNode* l2) { // 两两合并
        if (!l1) return l2;
        if (!l2) return l1;
        if (l1->val < l2->val) {
            l1->next = merge2Lists(l1->next, l2);
            return l1;
        } else {
            l2->next = merge2Lists(l1, l2->next);
            return l2;
        }
    }
};
```

### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]
```

#### 思路

> LRU缓存关键**其一**在于`get`和`put`都必须以`O(1)`的时间复杂度，这其实已经指明了在LRU的内部我们要使用**Hash表**这个结构。其二在于超过capacity的时候，需要**逐出最久未使用**的关键字。这已经指明了我们不能使用数组这个结构。所谓的最久未使用其实就是先进先出的思想，不难想到使用**双向链表的队列+Hash表**实现LRU这个结构。每次`get`和`put`节点的时候，都将节点放到链表的头部，容量满的时候直接把链表尾部的结点扔掉。

```cpp
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value)
        : key(_key), value(_value), prev(nullptr), next(nullptr) {}
};

typedef DLinkedNode* List;

class LRUCache {
   private:
    unordered_map<int, List> cache; // 保存键和链表节点之间的联系
    List head;
    List tail; // 保存尾节点，利于删除链表尾部的结点
    int size;
    int capacity;

   public:
    LRUCache(int _capacity) : capacity(_capacity), size(0) {
        head = new DLinkedNode(); // 创建头节点和尾节点，便于后续的操作
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }

    int get(int key) {
        if (!cache.count(key)) { // 不存在该节点
            return -1;
        }
        List node = cache[key]; // 存在的话直接通过map返回节点
        moveToHead(node); // 将节点移动到链表的头部
        return node->value;
    }

    void put(int key, int value) {
        if (!cache.count(key)) { // 不存在，新建节点插入
            List node = new DLinkedNode(key, value);
            cache[key] = node;
            addToHead(node);
            ++size;
            if (size > capacity) { // 超过容量将链表尾部的结点删除
                List removed = removeTail();
                cache.erase(removed->key); // 不要忘记在map中也要删除
                delete removed;
                --size;
            }
        } else { // 存在和get类型，查询返回
            List node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void addToHead(List node) { // 将节点放到头部
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }

    void removeNode(List node) { // 删除节点，因为有prev指针，所以不需要通过前一个结点删除
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void moveToHead(List node) { // 将节点移动到头部
        removeNode(node);
        addToHead(node);
    }

    List removeTail() { // 将尾部的节点删除
        List node = tail->prev;
        removeNode(node);
        return node;
    }
};
```

## 二叉树

### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```
#### 思路
> 中序遍历即先访问左子结点，访问根结点，再访问右子结点。使用**递归**很容易实现。

```cpp
typedef TreeNode* Tree;
class Solution {
   public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        midOrder(root, res);
        return res;
    }

   private:
    void midOrder(Tree root, vector<int>& res) { // 中序遍历
        if (!root) return;
        if (root->left) midOrder(root->left, res); // 左孩子
        res.push_back(root->val); // 根
        if (root->right) midOrder(root->right, res); // 右孩子
    }
};
```

> 使用一个**栈**来模拟递归也是可以的。

```cpp
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    if (!root) return res;
    stack<Node> stk;
    while (root || !stk.empty()) {
        while (root) { // 一直往左进栈
            stk.push(root);
            root = root->left;
        }
        root = stk.top(); // 此时root是最左的结点，他没有左结点
        stk.pop();
        res.push_back(root->val);
        root = root->right; // 访问他的右面
    }
    return res;
}
```

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

<img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img" style="zoom:50%;" />

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

#### 思路

> 二叉树的最大深度等于其**左右子树的最大深度+1**，可以用**递归**很容易实现。

```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right)
        : val(x), left(left), right(right) {}
};

class Solution {
   public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
```

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

<img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

#### 思路

> 先**递归翻转左右子树**，然后**交换**左右子树即可。

```cpp
TreeNode* invertTree(TreeNode* root) {
    if (!root) return root;
    Node left = root->left, right = root->right;
    root->left = invertTree(right);
    root->right = invertTree(left);
    return root;
}
```

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

<img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img" style="zoom:50%;" />

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

#### 思路

> 一开始我的思路是使用中序遍历，因为如果一个二叉树是对称的那么其中序遍历就是对称的。然而这个问题的逆命题并不成立，因为中序遍历对称不能得出原二叉树遍历。正确的做法是**递归的检查左子树和右子树**是否对称。

```cpp
class Solution {
   public:
    bool isSymmetric(TreeNode* root) { return check(root, root); }

   private:
    bool check(Node left, Node right) {
        if (!left && !right) return true;  //只有一个节点
        if (!left || !right) return false; //左右不全在为不对称
        // 本身相等  左子树的右和右子树的左相等  左子树的左和右子树的右相等
        return left->val == right->val && check(left->right, right->left) &&
               check(left->left, right->right);
    }
};
```

> 本题也可以利用两个**队列**来实现。两个队列分别遍历左子树和右子树的结点。左子树从左往右放，右子树从右往左放。

```cpp
bool isSymmetric(TreeNode* root) {
    Node left = root, right = root;
    queue<Node> lq, rq; // 使用两个队列遍历左右
    lq.push(root->left);
    rq.push(root->right);

    while (!lq.empty() && !rq.empty()) {
        if (lq.size() != rq.size()) return false;
        left = lq.front(), right = rq.front();
        lq.pop();
        rq.pop();
        if (!left && !right) continue;
        if ((!left && right) || (left && !right)) return false;
        if (left->val != right->val) return false;
        lq.push(left->left); // 左子树先放左再放右
        lq.push(left->right);
        rq.push(right->right); // 右子树先放右再放左
        rq.push(right->left);
    }
    return true;
}
```

### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

<img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

#### 思路

> 所谓的直径肯定是某个节点的**左子树最大深度+右子树的最大深度+1**。虽然这个直径可能经过也可能不经过根节点，但是我们在计算经过根节点的时候也会同时**递归计算其子节点**。只需要在每次计算的时候保存一下最大值即可。

```cpp
class Solution {
   public:
    int diameterOfBinaryTree(TreeNode* root) {
        depth(root); // 计算经过根节点的直径
        return ans;
    }

   private:
    int depth(Node node) {
        if (!node) return 0;
        int ld = depth(node->left); // 左子树深度
        int rd = depth(node->right); // 右子树深度
        ans = max(ans, ld + rd); // 保存一路上遇到的最大值
        return max(ld, rd) + 1;
    }
    int ans = 0;
};
```

### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

#### 思路

> 属于是模版题了，二叉树的**层序遍历**一般使用**队列**来实现。

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> layers;
    if (!root) return layers;
    queue<Node> q;
    q.push(root); // 根节点先进队
    while (!q.empty()) {
        vector<int> layer;
        int len = q.size(); // 记录当前层的元素个数
        for (int i = 0; i < len; i++) { // 当前层全部出队
            Node front = q.front();
            q.pop();
            layer.push_back(front->val);
            if (front->left) q.push(front->left); // 下一层全部进队
            if (front->right) q.push(front->right);
        }
        layers.push_back(layer); // 当前层进队完毕，将其加入到结果当中去
    }
    return layers;
}
```

### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵平衡二叉搜索树。

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

#### 思路

> 所谓的平衡二叉搜索树就是要左子树和右子树的结点数量差不多，所以不难想到要将**数组的中点作为根节点**。然后使用左面的数组和右面的数组**递归的构造左右子树**。

```cpp
class Solution {
   public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        int len = nums.size();
        return BSTHelper(nums, 0, len);
    }

   private:
    TreeNode* BSTHelper(vector<int>& nums, int start, int end) {
        if (start >= end) return nullptr;
        //int mid = start + ((end - start) >> 2); //结果为1 end=5,start=0
        int mid = start + ((end - start) / 2); //结果为2
        Node head = new TreeNode(nums[mid]); // 中点作为根节点
        head->left = BSTHelper(nums, start, mid); // 利用左边的数组构造左子树
        head->right = BSTHelper(nums, mid + 1, end); // 利用右面的数组构造右子树
        return head;
    }
};
```

### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含小于 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。



<img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [2,1,3]
输出：true
```

#### 思路

> 二叉搜索树的**中序遍历是有序**的，反之中序遍历有序一定也是二叉搜索树，可以利用这一点进行判断。

```cpp
class Solution {
   public:
    bool isValidBST(TreeNode* root) {
        vector<int> res;
        midOrder(root, res); // 得到中序遍历
        int len = res.size();
        for (int i = 1; i < len; i++) { // 中序遍历是否是有序的
            if (res[i] <= res[i - 1]) return false;
        }
        return true;
    }

   private:
    void midOrder(Node root, vector<int>& res) {
        if (!root) return;
        if (root->left) midOrder(root->left, res);
        res.push_back(root->val);
        if (root->right) midOrder(root->right, res);
    }
};
```

### [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

<img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

#### 思路

> 二叉搜索树的**中序遍历是有序的**，中序遍历输出的第k个元素就是树中第k小的元素。

```cpp
class Solution {
   public:
    int kthSmallest(TreeNode* root, int k) {
        this->k = k;
        midOrder(root);
        return this->ans;
    }

   private:
    int cot = 0; // 记录中序遍历的输出顺序
    int ans = 0;
    int k = 0;
    void midOrder(TreeNode* root) {
        if (!root) return;
        if (root->left) midOrder(root->left);
        if (++cot == k) {
            ans = root->val;
            return;
        }
        if (root->right) midOrder(root->right);
    }
};
```

### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img" style="zoom:50%;" />

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

#### 思路

> 最显而易见的办法就是利用**层序遍历**，最右侧能看到的结点就是层序遍历最右边的结点。

```cpp
vector<int> rightSideView(TreeNode* root) {
    vector<int> res;
    if (!root) return res;
    queue<Node> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            Node front = q.front();
            if (i == size - 1) res.push_back(front->val); // 本层最右边的结点
            q.pop();
            if (front->left) q.push(front->left);
            if (front->right) q.push(front->right);
        }
    }
    return res;
}
```

### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。



<img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

#### 思路

> 一眼看过去就是**递归**的题目，先**分别将左子树和右子树展开成链表**，然后根据先序的顺序将这三个链表连接即可。

```cpp
class Solution {
   public:
    void flatten(TreeNode* root) { root = flattenHelper(root); }

   private:
    Node flattenHelper(Node root) {
        if (!root) return root;
        Node lt = flattenHelper(root->left); // 左子树展开成链表
        Node rt = flattenHelper(root->right); // 右子树展开成链表
        root->right = lt; // 指向左子树
        Node p = root;
        while (p->right) { 
            p->left = nullptr; // 左子树设置为空
            p = p->right;
        }
        p->left = nullptr; // 找到lt的最后一个结点，将其指向右子树
        p->right = rt;
        return root;
    }
};
```

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。



<img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img" style="zoom:50%;" />

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

#### 思路

> 经典老题。先序的特点是**第一个元素是根结点**。在中序中找到先序的根节点，我们可以知道，其**左边的是其左子树**，**右面的是其右子树**。据此进行递归的构造即可。

```cpp
class Solution {
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int len = preorder.size();
        return buildTreeHelper(preorder, inorder, 0, len - 1, 0, len - 1);
    }

   private:
    TreeNode* buildTreeHelper(vector<int>& preorder, vector<int>& inorder,
                              int ps, int pe, int is, int ie) {
        if (ps > pe || is > ie) return nullptr; // 下标非法，递归终止
        int h = preorder[ps]; // 开头的结点是根结点

        Node head = new TreeNode(h);
        if (ps == pe) return head; // 只有一个结点，返回
        int inhead = 0;

        for (int i = is; i <= ie; i++) {
            if (inorder[i] == h) {
                inhead = i; // 找到根节点在中序当中的位置
                break;
            }
        }

        // 计算左子树和右子树的长度以分割先序数组
        int lNum = inhead - is, rNum = ie - inhead;
        // 递归的构造左右子树即可
        head->left = buildTreeHelper(preorder, inorder, ps + 1, ps + lNum, is,
                                     inhead - 1);
        head->right = buildTreeHelper(preorder, inorder, ps + lNum + 1, pe,
                                      inhead + 1, ie);
        return head;
    }
};
```

### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

<img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

#### 思路

> 由于路径可以从根节点开始也可以不从根节点开始，我们可以进行**分类讨论**。先写一个**必须经过根节点**的路径总和函数，然后用此来实现可以从根节点开始也可以不从根节点开始的函数。

```cpp
typedef TreeNode *Node;
class Solution {
   public:
    int pathSum(TreeNode* root, int targetSum) {
        if (!root) return 0;
        // 返回经过根节点的和不经过根节点的路径总和
        return pathSumWithRoot(root, targetSum) +
               pathSum(root->left, targetSum) + pathSum(root->right, targetSum);
    }

   private:
    int pathSumWithRoot(Node root, long long targetSum) { // 经过根节点的路径总和
        int cot = 0;
        if (root->val == targetSum) cot++;
        if (root->left)
            cot += pathSumWithRoot(root->left, targetSum - root->val);
        if (root->right)
            cot += pathSumWithRoot(root->right, targetSum - root->val);
        return cot;
    }
};
```

> 此时的最优解是使用**前缀和**的方法。
>
> 将所有的结点**到根节点的路径和当作自己的前缀**。这样如果子节点的前缀和和祖先节点的前缀和的差为target的话，子节点和祖先节点之间的路径就是和为target的路径。
>
> 为了确保子节点要在父节点之后访问，我们需要使用**先序的dfs遍历**。进入dfs的时候将前缀**存入map**当中，离开dfs的时候需要将**前缀取出**。

```cpp
class Solution {
   public:
    int pathSum(TreeNode* root, int targetSum) {
        prefixs[0] = 1; // 初始化0，这个表示这条路径到根节点就是目标值
        return dfs(root, 0, targetSum);
    }

   private:
    unordered_map<long long, int> prefixs; // 防止溢出用long long
    int dfs(Node root, long long cur, int targetSum) {
        if (!root) return 0;

        cur += root->val; // 先序遍历确实父节点在子节点之前访问
        int res = prefixs[cur - targetSum]; // 前面遇到了几个符合要求的前缀
        prefixs[cur]++; // 存放前缀和
        res += dfs(root->left, cur, targetSum);
        res += dfs(root->right, cur, targetSum);
        prefixs[cur]--; // 子节点已经全部访问完毕，取出前缀和
        return res;
    }
};
```

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

#### 思路

> 如果我们发现**p和q分别在节点X的左右子树下**时，就可以说X是p和q的最近公共祖先。如果**p和q都在X的左子树**下，那么p和q的最近公共祖先一定在X的左子树当中，递归向左子树寻找即可。

```cpp
class Solution {
   public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root, p, q);
        return lca;
    }

   private:
    TreeNode* lca = nullptr; // 记录最近公共祖先
    bool dfs(Node root, Node p, Node q) { // root节点及其子树是否能找到p或q
        if (!root) return false;
        bool lson = dfs(root->left, p, q); // 左子树当中找p和q
        bool rson = dfs(root->right, p, q); // 右子树当中找p和q
        // 左右子树中分别发现了p和q，或者左右子树当中发现了一个，自己就是另一个
        if ((lson && rson) ||
            ((root->val == p->val || root->val == q->val) && (lson || rson)))
            lca = root;
        // 左子树有，右子树有，或者自己就是，说明也能找到
        return lson || rson || (root->val == p->val || root->val == q->val);
    }
};
```

### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。



<img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

#### 思路

> 由于根节点可以包含也可以不包含，很容易想到之前的分类讨论的思路，即写一个**必须经过根节点**的路径总和。这里需要注意的是，由于是求最大路径，所以在经过根结点的实现当中，**只有根结点的位置可以左右子树同时走**，其他的结点**只能选择走一个更大的子树。**

```cpp
typedef TreeNode *Node;
class Solution {
   public:
    int maxPathSum(TreeNode *root) {
        int res = maxPathSumWith(root); // 走根节点的最大路径
        if (root->left) res = max(res, maxPathSum(root->left)); // 不走根节点走左子树的最大路径
        if (root->right) res = max(res, maxPathSum(root->right)); // 走右子树
        return res;
    }

   private:
    int maxPathSumWith(Node root) { // 必须经过根节点
        int res = root->val;
        if (root->left) res += max(0, maxPathSumWithOne(root->left));
        if (root->right) res += max(0, maxPathSumWithOne(root->right));
        return res;
    }

    int maxPathSumWithOne(Node root) { // 子节点只能选择要么走左子树要么走右子树
        int res = root->val;
        if (!root->left && !root->right) return res;
        if (root->left && root->right)
            return res + max(0, max(maxPathSumWithOne(root->left),
                                    maxPathSumWithOne(root->right)));
        if (root->left) return res + max(0, maxPathSumWithOne(root->left));
        return res + max(0, maxPathSumWithOne(root->right));
    }
};
```

> 事实上这题和**二叉树的直径**那题较为相似。我们在**计算经过根节点的最大的路径**的时候，**同时也会计算所有节点**的最大路径，我们在计算的时候更新最大值即可。

```cpp
typedef TreeNode *Node;
class Solution {
   public:
    int maxPathSum(TreeNode *root) {
        dfs(root);
        return max_path;
    }
   private:
    int max_path = INT_MIN;
    int dfs(Node root) { // 计算每个结点能提供的最大的路径值，即只能选择一颗子树
        if (!root) return 0;
        int res = root->val;
        int left = max(dfs(root->left), 0);
        int right = max(dfs(root->right), 0);
        // 计算结点的贡献值的同时，计算以该结点作为根的时候的最大路径
        max_path = max(max_path, root->val + left + right);
        return root->val + max(left, right); // 返回该节点的最大路径值
    }
};
```

## 图论

### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

#### 思路

> 每次**遇到1**之后就开始**dfs**，将与之相连的1全都变为0。最终**dfs的次数**就是岛屿的数量。

```cpp
class Solution {
   public:
    int numIslands(vector<vector<char>>& grid) {
        int cot = 0;
        m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') { // 遇到1开始dfs
                    dfs(grid, i, j);
                    cot++; // 保存dfs的次数
                }
            }
        }
        return cot;
    }

   private:
    int m, n;
    void dfs(vector<vector<char>>& grid, int x, int y) {
        grid[x][y] = '0'; // 变成0，并且往四个方向dfs
        if (x + 1 < m && grid[x + 1][y] == '1') dfs(grid, x + 1, y);
        if (x - 1 >= 0 && grid[x - 1][y] == '1') dfs(grid, x - 1, y);
        if (y + 1 < n && grid[x][y + 1] == '1') dfs(grid, x, y + 1);
        if (y - 1 >= 0 && grid[x][y - 1] == '1') dfs(grid, x, y - 1);
    }
};
```

> 同样是**BFS**遍历也是可以的，但是本题当中没啥必要，因为DFS的代码更加的简洁。

```cpp
class Solution {
   public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int count = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
                    bfs(grid, i, j);
                    ++count;
                }
            }
        }
        return count;
    }

   private:
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    void bfs(vector<vector<char>>& grid, int x, int y) {
        grid[x][y] = '0';
        queue<pair<int, int>> q;
        q.push({x, y});
        while (!q.empty()) {
            auto [row, col] = q.front();
            q.pop();
            for (int i = 0; i < 4; ++i) {
                int newX = row + dx[i];
                int newY = col + dy[i];
                if (newX >= 0 && newX < grid.size() && newY >= 0 &&
                    newY < grid[0].size() && grid[newX][newY] == '1') {
                    grid[newX][newY] = '0';
                    q.push({newX, newY});
                }
            }
        }
    }
};

```

### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png)**

```
输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
输出：4
```

#### 思路

> 实质上就是计算新鲜橘子距离烂橘子的**最远距离**，这种题目一般都是使用**BFS**来解决。先将**所有的烂橘子加入队列**当中，并且统计新鲜橘子的数量，开始BFS。BFS的层树就是最远距离，但是如果BFS结束还有新鲜橘子没有腐烂完，返回-1即可。

```cpp
int orangesRotting(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    int cot = 0, timer = 0;
    queue<pair<int, int>> q;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 2) q.push({i, j}); // 烂橘子加入队列
            if (grid[i][j] == 1) cot++; // 计算新鲜橘子的数量
        }
    }

    while (!q.empty()) {
        int k = q.size();
        for (int i = 0; i < k; i++) { // 每一秒的腐烂过程
            auto [x, y] = q.front();
            q.pop();
            for (int j = 0; j < 4; j++) {
                int newX = x + dx[j];
                int newY = y + dy[j];
                if (newX >= 0 && newX < m && newY >= 0 && newY < n &&
                    grid[newX][newY] == 1) {
                    grid[newX][newY] = 2;
                    q.push({newX, newY});
                    cot--;
                }
            }
        }
        if (!q.empty()) timer++;
        if (cot == 0) return timer; // 橘子全部腐烂，返回
    }
    if (cot != 0) return -1; // 还有橘子没烂
}
```

### [207. 课程表](https://leetcode.cn/problems/course-schedule/)

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

#### 思路

> 典型的任务调度类型的题目，使用**拓扑排序**可以生成一个适合的调度顺序。此外拓扑排序也可以检测数组当中是否有环。

```cpp
class Solution {
   public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses); // 邻接表
        indeg.resize(numCourses); // 入度
        for (auto& info : prerequisites) {
            edges[info[1]].push_back(info[0]);
            indeg[info[0]]++;
        }
        queue<int> q;
        for (int i = 0; i < numCourses; i++) {
            if (indeg[i] == 0) { // 找到所有入度为0的结点加入队列
                q.push(i);
            }
        }
        int visit = 0;
        while (!q.empty()) {
            visit++;
            int u = q.front();
            q.pop();
            for (int v : edges[u]) { // 删除节点和其连接的边
                if (--indeg[v] == 0) { // 也就是和其相连的结点的入度减一
                    q.push(v); // 如果发现入度为0，加入队列
                }
            }
        }
        return visit == numCourses; // 拓扑排序是否访问完了所有的结点
    }

   private:
    vector<vector<int>> edges;
    vector<int> indeg;
};
```

> 然而这题并没有让我们给出**任务调度的顺序**，因此我们也可以时间**dfs**来判断**图中是否有环**。可以在dfs之前标记当前结点为1，即**正在访问**，dfs结束之后标记当前结点为2，即已经**结束访问**。如果发现其后续节点能**访问到标记为1**的结点，则说明**图有环**。

```cpp
class Solution {
   public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        visit.resize(numCourses);
        for (int i = 0; i < prerequisites.size(); i++) {
            edges[prerequisites[i][1]].push_back(prerequisites[i][0]);
        }
        for (int i = 0; i < numCourses; i++) {
            if (!visit[i] && valid) {
                dfs(i);
            }
        }
        return valid;
    }

   private:
    vector<vector<int>> edges;
    vector<int> visit;
    bool valid = true; // 是否遇到了环

    void dfs(int u) {
        visit[u] = 1; // 正在访问
        for (int v : edges[u]) {
            if (!visit[v]) { // 之前没访问过的
                dfs(v);
                if (!valid) return;
            } else if (visit[v] == 1) { // 遇到了环如 1->3->4->1，
                valid = false;
                return;
            }
        }
        visit[u] = 2; // 访问结束
    }
};
```

### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

 #### 思路

> 前缀树的模板题。前缀树可以快速的查找**树中是否有以给定字符串为前缀**的单词，也可以查询树中是否有该单词。然而hash表只能查询树中是否有该单词。

```cpp
// 前缀树，又称字典树，可以快速的查询树中是否以给定的单词开头的字符串，即前缀
// 当我们把字符串反转插入的时候，也可以快速查后缀
class Trie {
   public:
    // 26个字母，保存为26个子节点
    vector<Trie*> child;
    // 当前的结点是否是一个单词的结尾
    bool is_end;
    Trie() : child(26, nullptr), is_end(false) {}

    // 插入一个单词
    void insert(string word) {
        Trie* cur = this;
        for (char ch : word) {
            int idx = ch - 'a';
            // 没有当前的子结点
            if (!cur->child[idx]) cur->child[idx] = new Trie();
            cur = cur->child[idx];
        }
        // 将最后一个节点标记为结束
        cur->is_end = true;
    }

    // 是否有当前的单词
    bool search(string word) {
        Trie* cur = this;
        for (char ch : word) {
            int idx = ch - 'a';
            if (!cur->child[idx]) return false;
            cur = cur->child[idx];
        }
        return cur->is_end;
    }

    // 是否有前缀为当前单词的, 和search的唯一区别是不需要验证is_end
    bool startsWith(string prefix) {
        Trie* cur = this;
        for (char ch : prefix) {
            int idx = ch - 'a';
            if (!cur->child[idx]) return false;
            cur = cur->child[idx];
        }
        return true;
    }
};
```

## 回溯

### [46. 全排列](https://leetcode.cn/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

#### 思路

> **回溯**的模版题。

```cpp
class Solution {
   public:
    vector<vector<int>> permute(vector<int>& nums) {
        int len = nums.size();
        vector<int> visit(len, 0);
        vector<int> path;
        permute(nums, path, visit);
        return res;
    }

   private:
    vector<vector<int>> res;
    void permute(vector<int>& nums, vector<int>& path, vector<int>& visit) {
        if (path.size() == nums.size()) { // 已经拿到了足够的字符数量
            res.push_back(path); // 加入结果
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (visit[i] == 1) continue; // 不拿重复的字符
            visit[i] = 1; // 标记为拿过
            path.push_back(nums[i]); // 加入路径当中
            permute(nums, path, visit);
            path.pop_back(); // 回溯，将字符从路径当中拿出
            visit[i] = 0; // 标记为没拿过
        }
    }
};
```

### [78. 子集](https://leetcode.cn/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

#### 思路

> 和上面的全排列类似，同样是回溯。但是这个回溯是有顺序的，从前到后每个元素都有**选或者不选**这两种选择。

```cpp
class Solution {
   public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int len = nums.size();
        vector<int> path;
        dfs(nums, path, 0);
        return res;
    }

   private:
    vector<vector<int>> res;
    void dfs(vector<int>& nums, vector<int>& path, int cur) {
        if (cur == nums.size()) { // 已经遍历到数组的结束了，直接返回
            res.push_back(path);
            return;
        }
        path.push_back(nums[cur]); // 选择本字符
        dfs(nums, path, cur + 1); // 往后继续
        path.pop_back(); // 回溯，不选择本字符
        dfs(nums, path, cur + 1); // 往后继续
    }
};
```

> 还有一种写法是**和全排列比较类似**的。

```cpp
class Solution {
   public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int len = nums.size();
        vector<int> path;
        subset(nums, path, 0);
        return res;
    }

   private:
    vector<vector<int>> res;
    void subset(vector<int>& nums, vector<int>& path, int index) {
        res.push_back(path); // 直接放入结果当中
        for (int i = 0; i < nums.size(); i++) {
            if (i < index) continue; // 防止重复，按照顺序选择
            path.push_back(nums[i]); // 放入该数字
            subset(nums, path, i + 1); // 开始下一个位置的选择
            path.pop_back(); // 取出该数字
        }
    }
};
```

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

#### 思路

> 本质上还是一个**排列选择**的问题，每个数字都有选择3到4个不同字母的方式。使用上面的模版即可。

```cpp
// 存放数字对于的字母
string m[8] = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

class Solution {
   public:
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) return res;
        string path;
        dfs(digits, path, 0);
        return res;
    }

   private:
    vector<string> res;
    void dfs(string digits, string path, int index) {
        if (path.size() == digits.size()) {
            res.push_back(path);
            return;
        }
        string str = m[digits[index] - '2']; // 数字对应的字母有哪些
        for (int i = 0; i < str.size(); i++) {
            path.push_back(str[i]); // 放入该字符
            dfs(digits, path, index + 1); // 看下一个数字
            path.pop_back(); // 取出该字符
        }
    }
};
```

### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
```

#### 思路

> 每个元素除了选一次和不选，现在还可以多选。可以先将数组排序，降低后面选择的复杂度。不断地向后选择直到和大于target回溯。

```cpp
class Solution {
   public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end()); // 排序降低复杂度
        vector<int> path;
        dfs(candidates, path, 0, 0, target);
        return res;
    }

   private:
    vector<vector<int>> res;
    void dfs(vector<int>& candidates, vector<int>& path, int sum, int index,
             int target) {
        if (sum > target) return; // 和太大直接退出没有选的必要了
        if (sum == target) { // 找到了目标和
            res.push_back(path);
            return;
        }
        int len = candidates.size();
        for (int i = 0; i < len; i++) {
            if (i < index) continue; // 可以重复选，但是不可以选之前更小的
            path.push_back(candidates[i]); // 放入选择列表
            sum += candidates[i]; // 和增加
            dfs(candidates, path, sum, i, target);
            sum -= candidates[i]; // 回溯，和减少
            path.pop_back(); // 取出选择列表
        }
    }
};
```

### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

#### 思路

> 当字符串里**左括号没放完**的时候，我们都可以放左括号。当字符串里面**左括号数量比右括号多**的时候，我们才能放右括号。可以**统计放入的左括号和右括号的数量**进行回溯。

```cpp
class Solution {
   public:
    vector<string> generateParenthesis(int n) {
        dfs(n, 0, 0, "");
        return res;
    }

   private:
    vector<string> res;
    void dfs(int n, int left, int right, string path) {
        if (left == n && right == n) { // 左括号和右括号都放完了，结束
            res.push_back(path);
            return;
        }
        // 左括号没放完，可以放左括号
        if (left < n) dfs(n, left + 1, right, path + '('); 
        // 左括号比右括号多，可以放右括号
        if (right < left) dfs(n, left, right + 1, path + ')'); 
    }
};
```

### [79. 单词搜索](https://leetcode.cn/problems/word-search/)

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

<img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img" style="zoom:50%;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

#### 思路

> 找到所有的**首字符进行dfs查询**即可。

```cpp
class Solution {
   public:
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size();
        n = board[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == word[0]) { // 找到了首字符
                    if (dfs(board, i, j, word, 1)) return true; // 对该位置进行dfs查询
                }
            }
        }
        return false;
    }

   private:
    int m, n;
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    int visit[10][10];
    bool dfs(vector<vector<char>>& board, int x, int y, string& word,
             int index) {
        visit[x][y] = 1; // 标记为已访问
        if (index == word.size()) return true; // 找到了该单词
        for (int i = 0; i < 4; i++) { // 想四个方向dfs寻找
            int newX = x + dx[i];
            int newY = y + dy[i];
            if (newX >= 0 && newX < m && newY >= 0 && newY < n &&
                !visit[newX][newY] && board[newX][newY] == word[index]) { // 找到了下一个字符
                visit[newX][newY] = 1;
                if (dfs(board, newX, newY, word, index + 1)) return true; // 继续找下一个字符
                visit[newX][newY] = 0;
            }
        }
        visit[x][y] = 0; // 恢复访问状态
        return false;
    }
};
```

### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文串。返回 `s` 所有可能的分割方案。

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

#### 思路

> 如果发现当前的字符是回文子串，递归访问后面的字符串继续找，如果没找到则回溯。我们手续要用动态规划的方法预处理一下字符串以快速的得到哪些区域是否是回文子串。

```cpp
class Solution {
   public:
    // isPalindrome[i][j]  = ((s[i] == s[j]) && isPalindrome[i + 1][j - 1])
    // i >= j => true
    vector<vector<string>> partition(string s) {
        vector<vector<string>> res;
        memset(isPalindrome, 1, sizeof(isPalindrome));
        int len = s.size();
        // 利用动态规划预处理字符串是否是回文子串，从长度为1开始
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i + 1; j < len; j++) {
                isPalindrome[i][j] =
                    (s[i] == s[j]) && isPalindrome[i + 1][j - 1];
            }
        }
        backtrack(s, 0, res, {});
        return res;
    }

   private:
    bool isPalindrome[20][20] = {0};
    void backtrack(string& s, int start, vector<vector<string>>& res,
                   vector<string> path) {
        if (start == s.size()) {
            res.push_back(path);
        } else {
            for (int i = start; i < s.size(); i++) {
                if (isPalindrome[start][i]) { // 如果 [start,i]是回文的
                    path.push_back(s.substr(start, i - start + 1)); // 放入路径
                    backtrack(s, i + 1, res, path); // 找下一个
                    path.pop_back(); // 回溯，取出路径
                }
            }
        }
    }
};
```

### [51. N 皇后](https://leetcode.cn/problems/n-queens/)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
```

#### 思路

> 回溯里面的最经典的问题，不过基本上都是考察8皇后问题。

```cpp
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        auto solutions = vector<vector<string>>();
        auto queens = vector<int>(n, -1);
        auto columns = unordered_set<int>();
        auto diagonals1 = unordered_set<int>();
        auto diagonals2 = unordered_set<int>();
        backtrack(solutions, queens, n, 0, columns, diagonals1, diagonals2);
        return solutions;
    }

    void backtrack(vector<vector<string>> &solutions, vector<int> &queens, int n, int row, unordered_set<int> &columns, unordered_set<int> &diagonals1, unordered_set<int> &diagonals2) {
        if (row == n) {
            vector<string> board = generateBoard(queens, n);
            solutions.push_back(board);
        } else {
            for (int i = 0; i < n; i++) {
                if (columns.find(i) != columns.end()) {
                    continue;
                }
                int diagonal1 = row - i;
                if (diagonals1.find(diagonal1) != diagonals1.end()) {
                    continue;
                }
                int diagonal2 = row + i;
                if (diagonals2.find(diagonal2) != diagonals2.end()) {
                    continue;
                }
                queens[row] = i;
                columns.insert(i);
                diagonals1.insert(diagonal1);
                diagonals2.insert(diagonal2);
                backtrack(solutions, queens, n, row + 1, columns, diagonals1, diagonals2);
                queens[row] = -1;
                columns.erase(i);
                diagonals1.erase(diagonal1);
                diagonals2.erase(diagonal2);
            }
        }
    }
	// 根据皇后序号生成棋盘
    vector<string> generateBoard(vector<int> &queens, int n) {
        auto board = vector<string>();
        for (int i = 0; i < n; i++) {
            string row = string(n, '.');
            row[queens[i]] = 'Q';
            board.push_back(row);
        }
        return board;
    }
};
```

