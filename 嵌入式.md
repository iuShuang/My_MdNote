## 嵌入式学习路径

![image-20240421150411985](D:\A_Document\Routine_Document\实习\学习\image-20240421150411985.png)

![image-20240421150442064](D:\A_Document\Routine_Document\实习\学习\image-20240421150442064.png)

![image-20240421150556184](D:\A_Document\Routine_Document\实习\学习\image-20240421150556184.png)

![image-20240421150653462](D:\A_Document\Routine_Document\实习\学习\image-20240421150653462.png)

![image-20240421150747473](D:\A_Document\Routine_Document\实习\学习\image-20240421150747473.png)

![image-20240421150814749](D:\A_Document\Routine_Document\实习\学习\image-20240421150814749.png)

![image-20240421150832985](D:\A_Document\Routine_Document\实习\学习\image-20240421150832985.png)

![image-20240421151012447](D:\A_Document\Routine_Document\实习\学习\image-20240421151012447.png)



## 单片机里的flash是什么

在单片机中，Flash（闪存）通常指的是一种`非易失性`存储器，用于存储程序代码、配置数据、用户数据等。Flash 存储器具有快速的读取速度和较高的耐久性，适用于嵌入式系统中程序的存储和更新。

以下是单片机中 Flash 存储器的一些特点和用途：

1. **存储程序代码**：Flash 存储器通常用于存储单片机的程序代码，包括初始化代码、应用程序、中断服务程序等。这些程序代码被写入 Flash 存储器后，在断电后依然可以被保持，确保了系统的持久性和稳定性。

2. **存储配置数据**：一些单片机的配置信息或参数可能会被存储在 Flash 存储器中，如时钟配置、IO口配置、通信参数等。这些配置数据在系统启动时被读取并加载，用于初始化系统。

3. **存储用户数据**：Flash 存储器也可以用于存储用户程序中产生的数据，如日志数据、用户设置等。这些数据可以在系统运行时被读取和修改，实现数据的持久性存储。

4. **固件更新**：由于 Flash 存储器可以被反复擦除和编程，因此它通常用于存储固件更新的数据。通过更新 Flash 存储器中的程序代码，可以实现单片机的软件升级和功能扩展，提高系统的灵活性和可维护性。

5. > **Bootloader**：有些单片机包含一个特殊的启动加载程序（Bootloader），它通常位于 Flash 存储器中。Bootloader 可以用于加载和执行系统启动时所需的初始化代码或固件，同时还可以支持固件更新等功能。

## 单片机中的中断演示

[用汇编讲中断，反而更简单！和你之前的理解可能不一样！来深入理解中断吧！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV17w411y7pj/?spm_id_from=333.788.recommend_more_video.1&vd_source=c4b26319211bc9ccc5ba3a0a22916e39)

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240328141719194.png" alt="image-20240328141719194" style="zoom:50%;" />

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240328141756768.png" alt="image-20240328141756768" style="zoom: 33%;" />

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240328141955365.png" alt="image-20240328141955365" style="zoom:33%;" />

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240328142110508.png" alt="image-20240328142110508" style="zoom: 80%;" />

![image-20240328142506377](D:\A_Document\Routine_Document\实习\学习\image-20240328142506377.png)

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240328143103346.png" alt="image-20240328143103346" style="zoom: 67%;" />

### 中断结束后如何恢复？

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240328143209676.png" alt="image-20240328143209676" style="zoom: 67%;" />

<img src="D:\A_Document\Routine_Document\实习\学习\image-20240328143258490.png" alt="image-20240328143258490" style="zoom:80%;" />

![image-20240328143347931](D:\A_Document\Routine_Document\实习\学习\image-20240328143347931.png)



## 通讯 CAN总线

- 可实现的功能：

  - 广播
  - 请求接收（先向某节点请求）
  - 过滤接收（can总线有广播）

- 线路少，无需共地

  ![image-20240421152258975](D:\A_Document\Routine_Document\实习\学习\image-20240421152258975.png)

- 两根通信线(CAN_H、CAN_L)，差分信号通信，抗干扰能力强

  - I2C单端(与差分相对)信号，所以得共地->至少三根线

- 11位（标准格式）/29位（扩展格式）报文ID，用于区分消息功能，同时决定优先级（多设备同时发送，ID小的先发送）

- `异步`，`半双工`，无需时钟线，`通信速率`由设备各自约定

- 可挂载多设备，多设备`同时发送数`据时通过`仲裁（排队）`判断先后顺序

- 可实现广播式和请求式两种传输方式

  - 一般都用广播式，接收方根据报文里的ID来过滤信息。

- 高速CAN，距离短；慢速CAN，距离长；

- 可配置1~8字节的有效载荷

  - 串口每次只能发送1字节。CAN可以指定发送任意1到8字节数据；

- 应答、CRC校验、位填充、位同步、错误处理等特性

#### CAN ≈ UART(简单易用)+IIC(多主机)+RS485(差分)

- IIC可以多主机，但不常用，一般用一主机+多从机
- SPI速度达到M级别，比CAN还快

![image-20240421154401889](D:\A_Document\Routine_Document\实习\学习\image-20240421154401889.png)

### CAN总线硬件电路

![image-20240421154848004](D:\A_Document\Routine_Document\实习\学习\image-20240421154848004.png)

- 每个设备通过CAN收发器挂载在CAN总线网络上
  - 每个设备例如STM32，得带有CAN控制器
- CAN收发器就是一个芯片，主要实现`电平转换`、`输出驱动`、`输入采样`几个功能

### CAN帧格式

![image-20240330150901101](D:\A_Document\Routine_Document\实习\学习\image-20240330150901101.png)





## [ARM的胞弟RISC-V](https://www.bilibili.com/video/BV1jt42157mp?spm_id_from=333.1245.0.0)

![image-20240330153356237](D:\A_Document\Routine_Document\实习\学习\image-20240330153356237.png)

![image-20240330153409915](D:\A_Document\Routine_Document\实习\学习\image-20240330153409915.png)

![image-20240330153450987](D:\A_Document\Routine_Document\实习\学习\image-20240330153450987.png)

![image-20240330153614408](D:\A_Document\Routine_Document\实习\学习\image-20240330153614408.png)

## USB 

- USB2.0要有4个阴角
- ![image-20240330154315590](D:\A_Document\Routine_Document\实习\学习\image-20240330154315590.png)
- 从USB3.0开始
  type a变成了9个阴角
- ![image-20240330154333435](D:\A_Document\Routine_Document\实习\学习\image-20240330154333435.png)
- 而type c的接口有24个阴角

![image-20240330154351277](D:\A_Document\Routine_Document\实习\学习\image-20240330154351277.png)

再来看它们的传输速率

![image-20240330154414081](D:\A_Document\Routine_Document\实习\学习\image-20240330154414081.png)

- 四阴角的a口的传输速率最高
- 480兆比特每秒
- 九阴角的a口
- 最高传输速率可达十几比特每秒
- 而c口的速率可达八十几比特每秒
- 可以看出
- 银角数越多
- 它的传输速率越更高
- 那引脚数量和传输速度
- 有什么样的关系呢
- 要搞清楚这个问题
- 我们首先要知道他们各个引脚的作用
- 就拿最传统的a口来说
- 它的1号引脚是VCC
- 相当于电源的正极
- 4号引脚是GND
- 相当于电源的负极
- 中间的两个是数据收发引脚
- 在我之前的认知中
- 简单的以为一个是发送数据的引脚
- 另外一个是数据接收引脚
- 但是当我查阅资料之后
- 发现并不是这样的
- USB2.0及之前版本都是半双光通讯
- 也就是在同一时间
- USB的这两根线要么在发送数据
- 要么就是在接收数据
- 不能同时进行
- 这两根线是差分信号线

![image-20240330154512846](D:\A_Document\Routine_Document\实习\学习\image-20240330154512846.png)

- 2号引脚是地减
- 3号引脚是地加
- 用这两根线的插值
- 来表示数字信号的逻辑状态
- 常规的逻辑电瓶信号是这样的
- 0伏代表低电平
- 5伏代表高电平
- 而USB的插分信号是这样的
- 当地下电压高于地减时
- 表示逻辑高电平
- 当地下电压低于地减时
- 表示逻辑低电平

![image-20240330154555416](D:\A_Document\Routine_Document\实习\学习\image-20240330154555416.png)

- 所以说虽然它是有两根数据传输线
- 但其实本质上传输的是一个信号
- 那为什么不直接用一根数据线传输呢
- 这是因
- 为USB接口往往都会引出很长的线
- 如果只有一根线
- 比如突然来一个静电干扰
- 它的低电瓶就会变为高电瓶
- 这样就会影响数据的传输
- 而差分线是两根线
- 它是用两根线的电压差来传递信息
- 即使是某一点受到影响
- 那也是两根线也会同时受到影响
- 它们的差值就不会变
- 所以说差分信号抗干扰能力更强

![image-20240330154633181](D:\A_Document\Routine_Document\实习\学习\image-20240330154633181.png)

- 再来看USB3.0及之后的a口
- 它是在原来的4个引角的基础上
- 又增加了5个引角
- USB3.0之所以兼容2.0协议
- 就是下面还预留了2.0的通讯引脚
- 而上面的5个引脚是用作USB3.0通讯的
- 5号和6号引脚是一组差分信号
- 只负责发送数据
- 8号和9号引脚是一组差分信号
- 只负责接收数据
- 7号引脚是信号返回引脚
- 这样它就可以一边发送数据
- 一边接受数据了
- 也就是人们所说的全双弓

![image-20240330154719788](D:\A_Document\Routine_Document\实习\学习\image-20240330154719788.png)

- a口目前最高支持USB3.2协议

- USB3.2的最高传输速率是二十几比特

- 每秒但a口的传输速率最高

- 可达十几比特每秒

- 要是USB3.2接口

- 实现二十几比特每秒的速度

- 这就必须得用c口了

- 这是因为

- a口只有一个收发数据的通道

- 而c口有两个收发通道

- 所以即使是传输一样的协议

- c口的最高速度也可以比a口高一倍

- 最后再来看c口的24个银角

- 它之所以有这么多银角

- **`很大作用是为了实现正反差`**

- ![image-20240330155049473](D:\A_Document\Routine_Document\实习\学习\image-20240330155049473.png)

- 比如两端的GND一共占用了4个引角

- 但其实这4个引角是连着的

- 也就用了一根线

- 还有就是电源线

- VBOX也占用了4个引角

- 也合并成了一根线

- 这样的好处是无论我们正插还是反插

- 它的电源引角都可以正确对应

- 中间的四个为USB2.0阴角

- 只有传输2.0协议的时候使用

- 这四个阴角一共占用了两根线

- 这8个引脚是数据传输引脚

- 都是差分信号

- 它有两个数据传输通道

- 这样传输数据就会加倍

- 再来说它的C C 1 C C 2引脚

- 这两个引脚可以检测插头的方向

- 并且可以通过这两个引角

- 来协商供电协议

- 例如确定是充电器还是充电设备

- 以及协商电流电压参数

- SBU1引角和SBU2是附加功能引角

- 比如用于DP视频传输

- 或者其他类型的数据传输

- 这就是Typec接口24个引角的功能

- 它之所以比之前的a口

- 多出来这么多引角

- 其一是为了实现正反插拔

- 其二是又增加了一路传输通道

- 还有就是为了兼容USB2.0协议

- 但是USB的传输速度

- 跟c口引角的数量并没有关系

- 比如把2.0引角去掉

- 它的最高传输速度也不会受到影响

- c口眼角数量越多

- 它就可以实现更多的功能

- 比如兼容2.0传输视频

- 但是速度不一定快

- 这个主要得看它传输的是什么协议

- 可以看一下

- 都是c口

- 如果传输的USB协议不一样

- 那么速度就会有天壤之别

- 好了

- 这就是我对USB接口的一些简单理解

- 希望对你有帮助

  

## 什么是高阻态 

说白了就是切开电线，使之无法导通，呈现无穷大的电阻。

![image-20240331132319836](D:\A_Document\Routine_Document\实习\学习\image-20240331132319836.png)

高阻态的应用主要是在总线结构上，一般总线上会挂有多个设备，当主设备和其中一个从设备，建立通信的时候，其他的从设备IO一般都是高阻态，这样就不会影响正在通信的设备

![image-20240331131645165](D:\A_Document\Routine_Document\实习\学习\image-20240331131645165.png)

![image-20240331144414141](D:\A_Document\Routine_Document\实习\学习\image-20240331144414141.png)

> 这边电源直接对地短路/MOS管就烧毁了

## 为什么电源直接对地是短路且线路上的MOS管就烧毁了

当电源直接连接到地时，会形成一个短路，这意味着电流会不受限制地流过电路。如果MOSFET（金属氧化物半导体场效应管）连接在电源和地之间，那么它将承受整个电流，导致过载。如果MOSFET的额定电流低于短路电流，那么它可能会因过载而烧毁。这就是为什么在设计电路时，需要仔细选择MOSFET的额定电流，以确保它能够承受预期的电流负载，同时也需要在电路中加入保护措施，防止短路等故障情况发生。

## 推挽 开漏 高阻

![image-20240331120324590](D:\A_Document\Routine_Document\实习\学习\image-20240331120324590.png)

[[嵌入式开发面试题GPIO的输出什么时候用开漏什么时候用推挽_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ZN411p78Z/?spm_id_from=333.788.top_right_bar_window_history.content.click)](https://www.bilibili.com/video/BV1UG41187YV/?spm_id_from=333.337.search-card.all.click&vd_source=c4b26319211bc9ccc5ba3a0a22916e39)

[什么是GPIO的推挽输出和开漏输出_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1zL411L7sj/?spm_id_from=333.788.recommend_more_video.3&vd_source=c4b26319211bc9ccc5ba3a0a22916e39)

![image-20240331130632919](D:\A_Document\Routine_Document\实习\学习\image-20240331130632919.png)



![image-20240331130649023](D:\A_Document\Routine_Document\实习\学习\image-20240331130649023.png)

![image-20240331130714058](D:\A_Document\Routine_Document\实习\学习\image-20240331130714058.png)

![image-20240331130816077](D:\A_Document\Routine_Document\实习\学习\image-20240331130816077.png)

![image-20240331130846797](D:\A_Document\Routine_Document\实习\学习\image-20240331130846797.png)

![image-20240331130915104](D:\A_Document\Routine_Document\实习\学习\image-20240331130915104.png)

![image-20240331130926833](D:\A_Document\Routine_Document\实习\学习\image-20240331130926833.png)

![image-20240331131048219](D:\A_Document\Routine_Document\实习\学习\image-20240331131048219.png)

![image-20240331131308521](D:\A_Document\Routine_Document\实习\学习\image-20240331131308521.png)

> 有一个MOS管导通的时候，我们这个输出都是一个低电平

![image-20240331131209191](D:\A_Document\Routine_Document\实习\学习\image-20240331131209191.png)



- 那我问你一下
- GPIO的输出什么时候用开漏
- 什么时候用推挽呢
- 首先呢
- 我们要了解开漏和推挽的区别
- `开漏呢只能输出低电频`
- 如果需要输出高电频呢
- 就需要外部上拉电阻来实现
- `而推挽呢`
- 则既能实现输出高电频
- 又能输出低电频
- 不需要依赖外部的上拉电阻
- 那么不同情况下呢
- 应该选择哪种输出模式
- 第一种情况呢
- `外部有上拉电阻`
- 这种情况下呢
- `可以用开漏`
- `也可以用推网`
- `那什么时候选择开漏`
- 什么时候选择推网呢
- 如果你的电路设计`需要输出高电瓶`
- 那么就可以选择开漏
- 如果你的电路设计需要输出低电瓶
- 那么就可以选择推挽
- `第二种情况`
- `外部没有上拉电阻`
- 这种情况下呢
- 我们必须选择`推挽`
- `因为如果选择开漏呢`
- `就无法输出高电瓶`
- `第三种情况呢`
- `多个IO输出口呢连接到一个个输入口`
- 这种情况下呢
- 我们必须选择开漏
- 因为它有线与的功能
- 最后一种情况
- 需要接口呢
- 电瓶转换
- 这种情况下呢
- 我们必须选择开漏
- 最后一种情况，电平转换用开漏的原因如下：
  我们有一个3.3V的单片机，需要和一个5V的设备进行通信。如果直接使用单片机的普通输出，可能会因为电压过低而导致设备无法识别信号。但是如果配置为开漏输出，并使用5V的上拉电阻，那么当单片机输出低电平时，设备看到的是0V；当单片机不输出低电平时，由于上拉电阻的作用，设备看到的是5V。这样就实现了3.3V到5V的电平转换。



## 电子流动方向和电流相反

传统上，电流的方向是定义为正电荷的移动方向。但是，在大多数有导电性的物质中，实际移动的是负电荷的电子。因此，电子的移动方向与电流的方向恰恰相反。这个定义是在19世纪初由安东尼·阿莫斯·诺德霍夫（Antoine Amedee Berthollet）提出的，当时人们还不知道电流是由电子流动产生的。现在我们知道了这一点，但是电流的定义已经成为一种惯例，所以我们仍然将其定义为正电荷的移动方向。

- 自由电子是负电荷吗

是的，自由电子是指具有负电荷的电子。在导电性材料中，自由电子是指那些不受原子核吸引，可以自由移动在材料内部的电子。它们是导电现象的根本原因。自由电子的负电荷为-1.602 x 10^-19 C，这个单位也称为元电荷。

**电子流动方向**

是指电子在导电材料中移动的方向。电子在导电材料中以一定速度移动，类似于流体中的流动。在电路中，电子流动的方向是从电源的负极到正极。



**电流方向**

是指正电荷在电场中的移动方向。在电路中，电流方向是从电源的正极到负极。电流方向与电子流动方向是相反的。这是因为电路中的电流是由正电荷移动产生的，而正电荷移动的方向与电子流动的方向相反。

![img](D:\A_Document\Routine_Document\实习\学习\v2-30354ebcb7f880940466299428e5a226_720w.webp)



## STM32点亮一个LED灯

[STM32最复杂！同样是点亮一颗LED，难度相差悬殊！](https://www.bilibili.com/video/BV1QC4y1Q7WC?spm_id_from=333.1245.0.0)

![image-20240331133109636](D:\A_Document\Routine_Document\实习\学习\image-20240331133109636.png)



## UART SPI I2C RS232/485 CAN

### 基本性质对比

[DAY5 SPI总线_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1SK4y1X7jp?p=15&vd_source=c4b26319211bc9ccc5ba3a0a22916e39)

#### UART（串口）:串、异步、两根线、全双工

双方规定波特率--需要有自己的时钟源

![image-20240331165122829](D:\A_Document\Routine_Document\实习\学习\image-20240331165122829.png)

> 串口协议规定数据线在空闲的时候，那么数据线上的状态必须是高电平啊。
>
> UART 主要用于实现异步串行通信，不依赖外部时钟信号，而是通过发送端和接收端预先约定的波特率来进行数据的传输。

- 缺点：

  - UART通信时一般直接使用处理器使用的电平，即TTL电平（0，3.3v），但不同的处理器使用的电平存在差异， 所以不同的处理器使用UART通信时一般不能直接相连;

  - UART没有规定不同器件连接时连接器的标准，所以不同器件之间通过UART通信时连接很不方便;

![image-20240331170225339](D:\A_Document\Routine_Document\实习\学习\image-20240331170225339.png)

#### USART

- USART 可以根据需要配置为同步模式或异步模式，因此具有更大的灵活性和功能性。

- USART 通常包含发送（TX）、接收（RX）、`时钟（CLK）`和其他控制信号，可以支持更多的通信协议和功能。



#### RS232

![image-20240331170315090](D:\A_Document\Routine_Document\实习\学习\image-20240331170315090.png)

![image-20240331170357544](D:\A_Document\Routine_Document\实习\学习\image-20240331170357544.png)

![image-20240331170436199](D:\A_Document\Routine_Document\实习\学习\image-20240331170436199.png)

#### RS485(串、异步、半双工)

基于UART（串口）:串、异步、两根线；但两根线做差分，所以半双工。

![image-20240331170535577](D:\A_Document\Routine_Document\实习\学习\image-20240331170535577.png)

![image-20240331170830952](D:\A_Document\Routine_Document\实习\学习\image-20240331170830952.png)

![image-20240331170853961](D:\A_Document\Routine_Document\实习\学习\image-20240331170853961.png)

![image-20240331171211084](D:\A_Document\Routine_Document\实习\学习\image-20240331171211084.png)

#### I2C（串、同步、半双工）

![image-20240331172136213](D:\A_Document\Routine_Document\实习\学习\image-20240331172136213.png)

- IIC总线是一种多主机总线，连接在IIC总线上的器件分为主机和从机
- 主机有权发起和结束一次通信，`而从机只能被主机呼叫;`
- 当总线上有多个主机同时启用总线时，IIC也具备冲突检测和仲裁的功能来防止错误产生
- 每个连接到IIC总线上的器件都有一个唯一的地址(7bit)，
- 且每个器件都可以作为主机也可以作为从机(同一时刻只能有一个主机).
- 总线上的器件增加和删除不影响其他器件正常工作;
- IIC总线在通信时总线上发送数据的器件为发送器，接收数据的器件为接收器;

![image-20240331193919468](D:\A_Document\Routine_Document\实习\学习\image-20240331193919468.png)

#### IIC总线通信过程

1. 主机发送起始信号启用总线

2. 主机发送一个字节数据指明从机地址和后续字节的传送方向

3. 被寻址的从机发送应答信号回应主机

4. 发送器发送一个字节数据

5. 接收器发送应答信号回应发送器

6. (循环步骤4、5)

7. 通信完成后主机发送停止信号释放总线

   

   ![image-20240331193744169](D:\A_Document\Routine_Document\实习\学习\image-20240331193744169.png)

   

#### SPI（串、同步、全双工、高速的）

![image-20240331194408734](D:\A_Document\Routine_Document\实习\学习\image-20240331194408734.png)

![image-20240331194546494](D:\A_Document\Routine_Document\实习\学习\image-20240331194546494.png)

### CAN

异步通信；串行通信；半双工；

CAN是多主从结构，每个节点都有CAN控制器，

多个节点发送时，以发送的ID号自动进行仲裁，这样就可以实现总线数据不错乱，

而且一个节点发完，另一个节点可以探测到总线空闲，

而马上发送，这样省了主机的问，提高了总线利用率，增强了快速性。

所以在汽车等实性要求高的系统，都是用CAN总线。


### 简介

在一个单片机系统里
总是会有各种各样的外设
比如说SD卡
加速度传感器
屏幕GPS温湿度传感器等等
那单片机需要和他们通信来获取数据
或者说给他们写入数据
那有的时候呢
单片机还需要和
另外一块电路板上的单片机系统
甚至是电脑进行通信
那在这些通信的过程中
就需要用到不同的通信方式
常见的有UART、 i2C、SPI、RS232等等

![image-20240331140909703](D:\A_Document\Routine_Document\实习\学习\image-20240331140909703.png)

所以我们为什么需要
这么多不同的通信方式呢
它们各自的应用场景又是什么呢
那在这里面

### UART

因为大部分人入门单片机时
最早接触的也就是它
`俗称串口通信`
初始化之后
只需要这么一行代码
就可以给其他设备发送hello word了
用于调试非常的方便
它的物理层其实就是两根线
一根发送一根接收

![image-20240331141133199](D:\A_Document\Routine_Document\实习\学习\image-20240331141133199.png)

双方约定好通信的速度
比如说9600BPS。然后以这种数据包的形式
给对方发送数据
一次呢发送8位
也就是一个字节的数据
`你可以发现它的两根线是相互独立的`
也就是说
`两边可以同时发送数据给对方`
那看上去
串口这种通信方式非常的不错
简单方便
但是其实它也有一些缺点
最主要的有三个
第一个是不能远距离传输信号
第二个是通信速度有点慢
第三个是原则上只支持一对一的通信
不能支持一对多的通信
那针对以上这几个问题呢
就分别衍生出了一些其他的通行方式

![image-20240331141230379](D:\A_Document\Routine_Document\实习\学习\image-20240331141230379.png)

### RS232和RS485

因为串口通信使用的是TTL电平（晶体管-晶体管逻辑电平）

> [TTL](https://baike.baidu.com/item/TTL/13973249?fromModule=lemma_inlink)[电平](https://baike.baidu.com/item/电平/5695184?fromModule=lemma_inlink)信号规定，+5V等价于逻辑“1”，0V等价于逻辑“0”(采用[二进制](https://baike.baidu.com/item/二进制/361457?fromModule=lemma_inlink)来表示数据时)。这样的[数据通信](https://baike.baidu.com/item/数据通信/897073?fromModule=lemma_inlink)及电平规定方式，被称做TTL（[晶体管](https://baike.baidu.com/item/晶体管/569042?fromModule=lemma_inlink)-晶体管[逻辑电平](https://baike.baidu.com/item/逻辑电平/2772610?fromModule=lemma_inlink)）[信号系统](https://baike.baidu.com/item/信号系统/22324481?fromModule=lemma_inlink)。这是[计算机处理器](https://baike.baidu.com/item/计算机处理器/10313260?fromModule=lemma_inlink)控制的设备内部各部分之间[通信](https://baike.baidu.com/item/通信/300982?fromModule=lemma_inlink)的标准技术。

所以它只能在很短的距离内做通信
一般就认为
是在同一块电路板上的两个芯片
或者是两块距离很近的电路板之间
否则的话信号`非常容易受到干扰`
如果要进行远距离通信
就需要加入专门的芯片
来对信号进行抗干扰的处理
那这就衍生出了RS 232和RS 485通信

![image-20240331141517722](D:\A_Document\Routine_Document\实习\学习\image-20240331141517722.png)

那像232
`最大通信距离可以支持到30米左右`
而485的话
`最大通信距离甚至可以超过1千米`
同时呢` 485还增加了一对多的通信功能`
所以
虽然485比在座的大部分人年纪都要大
但是凭借着简单易用又稳定的性能
在很多领域依然被广泛使用着

### SPI

然后说回UART的第二个缺点
通信速度慢
大部分情况下
我们使用的最高串口波特率
也就是115200
那这个速度下
一小时都写不满一张64兆的SD卡
那究其原因
其实就是因为他的通信需要

- `双方约定波特率`
- `那这是一件不太靠谱的事情`
- `因为早期单片机频率比较低`
- `以及时钟精度的问题`
- `所以双方的波特率`
- `并不可能做到完全的一致`

![image-20240331141658596](D:\A_Document\Routine_Document\实习\学习\image-20240331141658596.png)传

输速度太快的话很容易误码
那解决这个问题的办法

- 就是加入一个clock信号
- 双方不需要约定具体的通信速度
- 发送端发送一个比特数据时
- 只需要同时给一个clock的上升沿
- 接收端这边收到上升沿的信号后
- 就去数据线上拿数据
- ![image-20240331141924036](D:\A_Document\Routine_Document\实习\学习\image-20240331141924036.png)

这样
就完全不依赖于系统时钟的准确度了
单纯靠时钟来做信号的同步
所以SPI的最高通信速率
可以轻松的突破10兆
那像SD卡
`屏幕这种对通信速度有要求的外设`
很多都会使用SPI接口
最后说一下串口的第三个问题
就是原则上不支持一对多的通信
如果你的系统里有很多个传感器
那就需要多个窗口去挨个连接
这样就很浪费资源

![image-20240331142027293](D:\A_Document\Routine_Document\实习\学习\image-20240331142027293.png)

### i2c通信

它最大的优势
就是支持多设备互相通信

- 一共有两根线
- 一根是数据
- 一根是clock
- 它们构成了一个信息通道
- 称为总线
- 所有的设备都挂载在这个总线上
- 每个设备都有一个自己独立的ID
- 那单片机想要跟任意的设备通信时
- 只需要按照特定的通信协议
- 在这个总线上吼一嗓子挨几号设备
- ![image-20240331142148894](D:\A_Document\Routine_Document\实习\学习\image-20240331142148894.png)
- ![image-20240331142202270](D:\A_Document\Routine_Document\实习\学习\image-20240331142202270.png)

给我你的数据
那这个时候
其他的设备听到不是在叫自己
就会自动的忽略掉这个指令
而被叫到的设备就会上传对应的数据
不过也正是因为有了总线的概念
所以i2c通信协议
也相对前面几个要复杂一些

- 而且还有一些高级功能
- 比如说支持多主通信什么的

那看到这里
今天的视频也就差不多结束了
不过依然残存了很多的问题
比如说为什么UAT的TTL电瓶
不支持远距离通信
同时他又为什么不支持一对多的通信
这么连接不可以吗
而芳西通信的具体通信协议
又是什么样子的
那这些问题
我也会在后面的视频里
单独给大家挨个介绍
今天的视
频我们主要记住每种通信方式
适用的场景
就可以了

## I2C通信细节

I2C总线的两根线分别是时钟和数据线
其中时钟是用来同步信号的
发送端在时钟的上升沿发出数据
接收端会在时钟的上升沿去取数据
那么问题就来了
某一时刻如果有两个设备同时要发送数据
要怎么办呢
比如说这个设备发送了一个一
也就是高电平
这个设备发送了一个零
也就是低电平
那这最终会发生什么呢
数据现象是高电平还是低电平
这其实也是I2C总线硬件设计中最精髓的地方
为了彻底搞清楚这个问题

### 我们先要弄明白芯片是如何输出高低电平的

在芯片IO口的内部
一般会有两颗mos管
上面的mos管导通就输出高电平
下面的mos管导通就输出低电平
这个时候我们把两个L口都挂在一根总线上
如果一个芯片输出高电平
一个芯片输出低电平
那么电流就直接这样从电源流入到D
这条通路其实就短路了

![image-20240331144824330](D:\A_Document\Routine_Document\实习\学习\image-20240331144824330.png)

后果就是必定会有一个元器件烧毁
那为了避免这种情况的发生
所以I2C总线对于设备的IO口做了一些阉割
去掉了上面的mos管
这样就不可能存在短路的情况了

![image-20240331144851482](D:\A_Document\Routine_Document\实习\学习\image-20240331144851482.png)

不过这样也就带来了另外一个问题
设备只能输出低电平
无法输出高电平了
那解决的办法就是
在总线上加入一颗这样的电阻
称为上拉电阻
关于上拉电阻的详细知识
可以去看一下这个视频
那加入这颗电阻之后呢

![image-20240331151707118](D:\A_Document\Routine_Document\实习\学习\image-20240331151707118.png)

- 这根总线默认就处于高电平的状态了
- 这颗芯片想要输出低电平
- 就把mos管打开
- 把总线信号拉低
- 那想要输出高电平
- 只需要关闭mos管
- 总线就被上拉电阻拉到高电平了
- 不知道你对这个电路会不会有曾相识的感觉
- 其实这就是一个典型的GPIO开漏输出


###  两个设备如果同时要发送信号怎么办

假设都要输出高电平
等于说两个mos管都关闭总线
默认处于高电平状态
这没有任何的问题
两个设备都要输出低电平
时等于说两个mos管都打开
那么总线处于低电平状态也没啥问题
一个输出高电平
一个输出低电平
那就是一个mos管
打开一个mos管关闭
最终总线处于低电平状态
这个时候虽然想而输出高电平的芯片
可能会因为需求没有被满足而感觉到不爽
但是至少不会有任何芯片受到伤害
整个电路是安全的

![image-20240331151756451](D:\A_Document\Routine_Document\实习\学习\image-20240331151756451.png)

那至于如何解决他不爽的问题
那就是软件协议要思考的问题呢
这个后面的视频里面会说
那看到这里
不知道你会不会注意到另外一个问题

### 就是这个电阻的取值应该是多少

这也是IFC电路设计中比较重要的一个问题
这个电阻既不能太大
也不能太小
一般就是几千欧姆
比较常用的是4.7000欧姆
如果这个电阻太小了
比如说只有100欧姆
那么在总线低电平时
这条通路的电流就有33个毫安
那这个电流对于信号来说已经是非常大了
不仅仅浪费能量
还有可能烧毁电路

![image-20240331152254065](D:\A_Document\Routine_Document\实习\学习\image-20240331152254065.png)

同时这边下面的这颗mos管导通时
电阻也不完全为零
多少会有一些电阻大一点的话
有可能到几十甚至上百欧姆
沙拉电阻取值太小的话
会导致下面的mos管
无法把总线电压拉低到低电平的状态
那么这颗电阻的取值太大又有什么问题呢
每一个设备的L口对D总是会有一些寄生电容
从低电平网高电平转换的过程中
需要通过这颗电阻给这些电容充电
所以IPHONE7信号上升时会有一个爬坡的过程

![image-20240331152341254](D:\A_Document\Routine_Document\实习\学习\image-20240331152341254.png)

电阻越大
给电容充电的速度也就越慢
对应爬坡的速度也就越慢

![image-20240331152359705](D:\A_Document\Routine_Document\实习\学习\image-20240331152359705.png)

严重的话就会导致信号失真

![image-20240331152444742](D:\A_Document\Routine_Document\实习\学习\image-20240331152444742.png)

所以一般随着总线设备的增加
也会适当的减少上拉电阻值
稳妥一些的话
修改完电阻之后
可以用示波器实际的看一下波形有没有问题好
那以上就是今天视频的全部内容了

### 简单的总结一下

为了解决多设备共用总线而不烧毁电路的问题
采用了开漏输出的方案
配合上拉电阻就可以完整的输出高低电平
那这个上拉电阻的取值一般在几千欧姆
总线设备多且通信速度要求高的话

电阻就小一些

![image-20240331152606068](D:\A_Document\Routine_Document\实习\学习\image-20240331152606068.png)

反之电阻就可以大一些
那最后也正是因为采用了开漏输出
加上拉电阻的
所以IFC信号的抗干扰能力是比较弱的

![image-20240331152628753](D:\A_Document\Routine_Document\实习\学习\image-20240331152628753.png)

它只适合于同一块电路板上芯片之间进行通信

![image-20240331152643608](D:\A_Document\Routine_Document\实习\学习\image-20240331152643608.png)

并不适合超过30cm电路板之间的通信

### 补充

串口通讯只能在两个设备之间进行
如果是3个设备互相通讯
那每个设备得需要两组串口
它其实是3组相互独立的串口通讯
如果是4个设备相互通讯就更加麻烦了
最突出的问题就是线路连接比较复杂
为了解决这个痛点

> 人们设计了一种总线通讯
> 总线通讯有很多种协议

![image-20240331155232908](D:\A_Document\Routine_Document\实习\学习\image-20240331155232908.png)

今天给大家介绍一下简单易懂的I2C通讯
I2C的全称是Inter-Integrated Circuit
意思是芯片与芯片之间的通讯
可以看一下，使用I2C通讯之后
即使有很多芯片
线路连接显的也非常简单
I2C通讯一般采用一主多从模式
比如我们的单片机是主机
而其它设备都是从机

![image-20240331155332741](D:\A_Document\Routine_Document\实习\学习\image-20240331155332741.png)

那它到底是如何通讯的呢？
以单片机向从设备写信息为例
可以看一下，这是一帧标准的写数据帧

![image-20240331155448433](D:\A_Document\Routine_Document\实习\学习\image-20240331155448433.png)

串口通讯的两根线分别是发送和接收
而I2C这两根线分别是时钟线和数据线
我们的这一帧写数据是由时钟线和数据线共同作用的
也就是在同一时间
它要么是在发送信息，要么就是在读取信息

![image-20240331155514497](D:\A_Document\Routine_Document\实习\学习\image-20240331155514497.png)

当处于空闲状态时 
数据线和时钟线都处于高电平状态

![image-20240331155559771](D:\A_Document\Routine_Document\实习\学习\image-20240331155559771.png)

而当开始传递信息时
比如传递第一位起始位
此时必须要在时钟信号为高电平期间
数据信号完成由高到低的跳变
也就是下降沿
这样起始信号就发送完成了

![image-20240331162219826](D:\A_Document\Routine_Document\实习\学习\image-20240331162219826.png)

接下来是7位设备地址码
因为我们有很多从设备
每一个从设备的地址码都是唯一的
为了区别要和哪一个从设备通讯
需要先发送7位地址码
7位不同的0或者1的排列组合
一共可以表示128种结果

![image-20240331162203316](D:\A_Document\Routine_Document\实习\学习\image-20240331162203316.png)

它的0或者1是这样表示的
当时钟线为高电平时
数据线上的数据必须保持稳定
比如时钟线为高时
数据线上的数据始终为高
这样就完成了逻辑1的传输
如果数据线上始终是低电平
则表示逻辑0

![image-20240331162328621](D:\A_Document\Routine_Document\实习\学习\image-20240331162328621.png)

比如我们发送一串这样的数据
它就表示 1010 000
也就是要和地址为1010 000的设备通讯

![image-20240331162350248](D:\A_Document\Routine_Document\实习\学习\image-20240331162350248.png)

假如24C02的地址就是1010 000
此时就是单片机和这个24C02通讯

![image-20240331162420913](D:\A_Document\Routine_Document\实习\学习\image-20240331162420913.png)

接下来的一位是读/写数据位
如果我们想要写数据，就给它置0
读数据是置1（此时置0）
再下面一位是应答信号
这个信号是由从机发送给主机的

![image-20240331162521678](D:\A_Document\Routine_Document\实习\学习\image-20240331162521678.png)

如果从机收到了之前的信息
它会回复0
没有收到或者（主机）读取接收完成回复1

![image-20240331162541312](D:\A_Document\Routine_Document\实习\学习\image-20240331162541312.png)

下面的8位是设备寄存器的地址
因为我们是给24C02通讯的
24C02是一个存储器
它可以存储256个字节
而我们发送的8位寄存器地址正好可以访问这256个字节
比如我们写的寄存器地址是0X01（0X01的二进制就是0000 0001）

![image-20240331162627543](D:\A_Document\Routine_Document\实习\学习\image-20240331162627543.png)

它就会往这里写入数据

![image-20240331162648691](D:\A_Document\Routine_Document\实习\学习\image-20240331162648691.png)

然后单片机需要存储器返回一个应答信号（此时为0）
接下来的8位是给这个存储器的寄存器要写入的数据
比如我们发送0000 1111

![image-20240331162801224](D:\A_Document\Routine_Document\实习\学习\image-20240331162801224.png)

则这8个位就会存储这8位信息

![image-20240331162818868](D:\A_Document\Routine_Document\实习\学习\image-20240331162818868.png)

即使后来断电
它里面依旧会永久的保存这些信息
发送完数据之后，需要再给主机发送应答信号0
告诉主机写入成功
最后再写入停止位

![image-20240331162850352](D:\A_Document\Routine_Document\实习\学习\image-20240331162850352.png)

它和起始位相反
是当时钟信号为高时
数据信号需要由低到高的跳变

![image-20240331162910117](D:\A_Document\Routine_Document\实习\学习\image-20240331162910117.png)

这样一个标准的写数据帧就完成了
那怎么读取数据呢？
其实读数据和写数据差不多

![image-20240331163114654](D:\A_Document\Routine_Document\实习\学习\image-20240331163114654.png)

可以看一下这是一个标准的读数据帧
它也是首先写入设备地址
然后是写数据
接下来写的是寄存器的地址
在收到从机的应答信号之后
主机需要再发送一个起始信号
然后需要再发送一遍设备的地址
然后才能发送读数据
接下来，存储器就会把寄存器里面的数据发送给单片机
这样就完成了一帧数据的读取（最后的应答信号为1，是由主机发给从机)





## 上拉电阻 

上拉电阻的取值也是有很多的
有的时候是1K
有的时候是4.7K或者10K
甚至是100K也是有的
那么上拉电阻到底要怎么取值呢
那今天的视频就来回答一下这两个问题
我相信搞清楚这两个问题之后
你对上拉电阻就会有一个比较清晰的认知了
先来看一下第一个问题
上拉电阻的作用是什么
或者说什么场景下需要用到上拉电阻
对于这几张图你会发现虽然他们不一样
但是其实他们是有共同点的
就是一般上拉电阻都会伴随着这颗mos管出现

![image-20240331145301684](D:\A_Document\Routine_Document\实习\学习\image-20240331145301684.png)

当我们把外面的电路都去掉
你会发现    
这其实就是一个工作在开漏模式的GPIO口
那上期视频也有提开漏模式
甲基有两种输出状态
mos管打开时输出低电平
mos管关闭时输出就等于什么都没有接

![image-20240331145439961](D:\A_Document\Routine_Document\实习\学习\image-20240331145439961.png)

- 不知道输出电压是多少
- 那这当然是不能接受的
- 所以就需要在外面给它加一个电阻
- 在mos管关闭时
- 输出电压被这个电阻拉到高电平状态
- 那这个电阻就是所谓的上拉电阻

![image-20240331145549362](D:\A_Document\Routine_Document\实习\学习\image-20240331145549362.png)

当然了
如果这个输出端接的后级输入中
极强的上拉电阻
那么你就可以不用在外面额外加上拉电阻了
然后在这张图中
这边有一个开关
也配了一颗上拉电阻
其实这个开关本质上和mos管是一样的
如果没有内部的这颗上拉电阻
当开关断开时
这边就处于一个电压不确定的浮空状态
所以上拉电阻的作用就很明显了
它本质上就是为了解决输出浮空状态时

![image-20240331150249523](D:\A_Document\Routine_Document\实习\学习\image-20240331150249523.png)

电压不确定而出现的
那这个时候就有人问了
这个电压经过一个电阻
为啥这边还是高电平电阻
不是会消耗电压吗
一般来说右边这里的等效输入阻抗都非常大
所以当左边这个mos管关闭时
基本不会有电流流过电阻
那自然这个点的电压就还是接近于3.3伏的

![image-20240331150421849](D:\A_Document\Routine_Document\实习\学习\image-20240331150421849.png)

然后是不要这个电阻直接降接行不行
那不要电阻的话
这颗mos管打开时
这边不就是短路了嘛

![image-20240331150443659](D:\A_Document\Routine_Document\实习\学习\image-20240331150443659.png)

所以肯定是需要这个电阻的
那然后我们来看一下一开始的第二个问题
上拉电阻要如何取值
这个问题就比较关键了
先说一个结论
绝大部分的上拉电阻取值都是在
1K到100K之间
一般来说电阻小的话
优点就是驱动能力比较强
缺点就是漏电流比较大
那反过来电阻大的话
优点就是漏电流小
缺点就是驱动能力弱

![image-20240331151133721](D:\A_Document\Routine_Document\实习\学习\image-20240331151133721.png)

那到底什么是漏电流
什么是驱动能力呢
先说一下漏电流

![image-20240331151201495](D:\A_Document\Routine_Document\实习\学习\image-20240331151201495.png)

所谓漏电流其实就是当这颗mos管打开时
这边就有一个通路
如果这个电阻是1K的话
那这边的这个漏电流就有5ma了
这个电流是白白浪费掉的
而且还会在系统里产生热量
所以考虑到漏电流这个因素
上拉电阻都是越大越好的
但是上拉电阻太大的话
驱动能力就弱了
那什么是驱动能力呢
一般来说在电路的这个点上
都会存在着一个对地的寄生电容
所以在低电平向高电平转换的过程中
你虽然看到的是这么一个瞬间的上升沿
但是其实把时间刻度放大了
看的话
低电平到高电平的转换不是瞬间完成的
它有一个爬升的过程
而这个爬升的过程其实就是通过这个电阻
给这个电容充电的过程
很明显电阻越大
这个爬升的过程也就越慢了
那这很有可能导致PWM或者IFC的波形
出现这样的失真

- 所以一般如果你只是控制后级的开关
- 这个上拉电阻可以大一些
- 没有问题
- 但是如果你要快速的切换
- 用于PWM或者IPHONEC的通信
- 那么这个上拉电阻尽量要控制在10K以内

![image-20240331151351496](D:\A_Document\Routine_Document\实习\学习\image-20240331151351496-1711869232515-3.png)

当然最稳妥的办法就是用示波器
看一下这个波形有没有问题
最后简单的总结一下
首先上拉电阻是为了解决浮空状态
电压不确定而出现的
然后上拉电阻太小的话
漏电流会比较大
上拉电阻太大的话
驱动能力又会比较小

![image-20240331151438520](D:\A_Document\Routine_Document\实习\学习\image-20240331151438520.png)

但是很多情况下
上拉电阻的取值并没有一个标准的值
差不多就行了
如果你拿捏不准的话
一般就是无脑的用10K的电阻
那今天的视频就到这里了
如果你觉得对你有帮助的话
别忘了关注和三连
我们下期再见拜拜



## SPI细节

> SPi是一种芯片和芯片之间的通讯

它的全称是Serial Peripheral Interface
这是采用了SPI通讯的电路连接图

> SPI通讯采用一主多从模式
> 也就是它只能有一个主机

从机可以有一个或者多个
SPI通讯需要4条信号线

![image-20240331163310950](D:\A_Document\Routine_Document\实习\学习\image-20240331163310950.png)

### 第一条是`片选信号线SS`

单片机通过给片选信号线高低电平来确定哪一个从机通讯

![image-20240331163336457](D:\A_Document\Routine_Document\实习\学习\image-20240331163336457.png)

一般当这根线为低电平时，片选才有效
### 第二条是`时钟信号线SCK`

它的信号是这样的
由主设备产生

![image-20240331163414720](D:\A_Document\Routine_Document\实习\学习\image-20240331163414720.png)

### 第三条是`发送信号线MOSI`

全称是Master output（主机输出）Slave input（从机输入）

![image-20240331163438731](D:\A_Document\Routine_Document\实习\学习\image-20240331163438731.png)

也就是主设备从这条线上输出数据
而从设备通过这条线上接受数据
### 第四条是`接收信号线MISO`

![image-20240331163501364](D:\A_Document\Routine_Document\实习\学习\image-20240331163501364.png)

主设备通过这根线接收数据
那这4根线是怎么实现SPI通讯的呢？
接下来用SPI读写93C46里面的数据
让大家对SPI通讯有一个更加深入地了解
在讲SPI通讯之前
我们得先了解93C46是什么
93C46是一个EEPROM存储器
等同于电脑的固态硬盘
它有1024位存储空间
也就是128个字节
每一个字节都有属于它的地址
它可以经受100万次擦写
数据可以保存100年
那怎么读写片内的这1024位的数据呢
最直接的办法是给每一位都外接一根线
但这显然是不现实的
因此SPI就发挥出它的优势了
通过SPI，只需要4根线
单片机就可以完全读写片内的这1024位数据了

- 先说片选信号线SS
- 如果我们要和93C46通讯
- SS1应该是高电平还是低电平呢？
- 绝大多数都是低电平有效
- 但是也有例外
- 数据手册上说它的SS在高电平期间才有效
- 所以这时候连接93C46的片选信号就应该给它高电平

![image-20240331163755142](D:\A_Document\Routine_Document\实习\学习\image-20240331163755142.png)

而其它的从机要就不要生效
此时单片机就和存储器93C46建立通讯了
为了便于理解
我们暂不展示其它的从机
先说怎么给存储器写入数据
比如我们要给存储器写入0000 1111
写入数据的地址为0X01（二级制 000 0001）
也就是这一个字节
那怎么给它写入这一串数据呢？
这个还得参考存储器的数据手册
可以看一下
要想写数据
首先需要给存储器发送起始位1
然后再发送写数据的操作码01
然后是7位地址码
因为只有128个字节
这7位地址码不同的排列组合就有128种结果
正好访问存储器的128个字节
因为我们要访问的地址是0X01
所以这里的地址码就是000 0001
最后再发送我们要写入的数据0000 1111
这样存储器的这个地址的数据就会保存0000 1111这一串数据

![image-20240331163926254](D:\A_Document\Routine_Document\实习\学习\image-20240331163926254.png)

那是不是只要把这些高低电平通过MOSi引脚发出去
数据就能成功写入呢？

![image-20240331163955224](D:\A_Document\Routine_Document\实习\学习\image-20240331163955224.png)

不是的，因为SPi是串行同步通讯
因此我们的这个数据线要和时钟线两根线配合
才能给存储器发送数据
可以看一下，真正的一帧SPI写数据是这样的
当片选信号被拉高之后，从设备开始生效
接下来关键的来了
只有在时钟信号的上升沿，数据信号才会被采样
也就是在时钟信号的上升沿这一刻
数据信号如果是1
它采集到的就是1
如果这一瞬间是0
它采集到的就是0
有几个上升沿，就会传输多少个数据
数据线和时钟线就是这样配合来发送数据的

![image-20240331164152037](D:\A_Document\Routine_Document\实习\学习\image-20240331164152037.png)

> 之所以在时钟的上升沿采集数据
> 是由这个从设备存储器决定的

要想给它写数据，我们必须这么发送数据
这种采集方式只是SPI的一种模式
还有其它的采集模式
比如只有在时钟的下降沿采集
以上这两种模式的空闲时钟都是低电平
还有两种模式是当时钟空闲为高电平时
在它的上升沿或者下降沿采集数据
算下来一种4种采集方式
具体要用哪一种采集方式，需要我们查阅芯片的数据手册
说完怎么写数据之后，接下来我们再来说一下怎么读数据
我们接下来读取地址0X01里面的数据
在读数据的时候，也必须得给它先写数据（只针对这个存储器)
可以看一下芯片的指令集
要想读取这里面的数据
首先得给它写入这10位数据
第一位是起始位1
接下来是读数据的操作码10
告诉从机我们要读数据
然后发送要读取的地址0X01
接下来我们就能收到这个地址里面的数据了
接收数据用的是时钟线和数据输入线
即使只接收不发送数据
主机也得继续给它提供时钟信号
这就是SPI读写存储器的全过程
那是不是SPI通讯的读写数据就必须得有这么多位呢？
完全不是的
SPI通讯对于一帧数据有多少位没有规定
这个完全取决于芯片的设定了
不管是一位数据或者一百位数据
只要符合SPI的这四种采样模式和电气属性，它就属于SPI通讯
这就是我对SPI通讯的理解，希望对你有帮助！