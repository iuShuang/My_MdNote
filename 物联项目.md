# HAL库简介

**STM32 HAL**固件库是Hardware Abstraction Layer的缩写，中文名称是：**硬件抽象层**。HAL库是ST公司为STM32的MCU最新推出的`抽象层嵌入式软件`，为更方便的实现跨STM32产品的最大可移植性。HAL库的推出，可以说ST也慢慢的抛弃了原来的`标准固件库`，这也使得很多老用户不满。但是HAL库推出的同时，也加入了很多第三方的中间件，有RTOS，USB，TCP / IP和图形等等。

![img](D:\A_Document\Routine_Document\实习\学习\format,png.png)

和标准库对比起来，STM32的HAL库更加的抽象，ST最终的目的是要实现在STM32系列MCU之间无缝移植，甚至在其他MCU也能实现快速移植

## HAL 库文件调用结构

![image-20200714213700726](D:\A_Document\Routine_Document\实习\学习\format,png-1711973716045-7.png)

## HAL的初始化

HAL层被调用前要先运行初始化函数HAL_init()，它包含在针对HAL自身的全局操作操作的源文件hal.c里。

HAL全局结构

![这里写图片描述](D:\A_Document\Routine_Document\实习\学习\20150611131409920.png)

## STM32 HAL库句柄、MSP函数、Callback函数

### 句柄

句柄（handle），有多种意义，其中第一种是指程序设计，第二种是指Windows编程。现在大部分都是指程序设计/程序开发这类。

第一种解释：`句柄是一种特殊的智能指针 `。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄。

第二种解释：整个Windows编程的基础。`一个句柄是指使用的一个唯一的整数值`，即一个`4字节`(64位程序中为8字节)长的数值，来标识应用程序中的不同对象和同类中的不同的实例，`诸如，一个窗口，按钮，图标，滚动条，输出设备，控件或者文件等。`应用程序能够通过句柄访问相应的对象的信息，但是句柄不是指针，程序不能利用句柄来直接阅读文件中的信息。如果句柄不在I/O文件中，它是毫无用处的。 句柄是Windows用来标志应用程序中建立的或是使用的唯一整数，Windows大量使用了句柄来标识对象。


## **STM32的标准库中，句柄是一种特殊的指针，通常指向结构体！**

在STM32的标准库中，假设我们要初始化一个外设（这里以USART为例），我们首先要初始化他们的各个寄存器。`在标准库中`，这些操作都是利用`固件库结构体变量`+`固件库Init函数`实现的：

	USART_InitTypeDef USART_InitStructure;
	
	USART_InitStructure.USART_BaudRate = bound;//串口波特率
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
	
	USART_Init(USART3, &USART_InitStructure); //初始化串口1

可以看到，要初始化一个串口，需要：

- 1、对六个位置进行赋值，
- 2、然后引用Init函数，

USART_InitStructure并不是一个全局结构体变量，而是只在函数内部的局部变量，初始化完成之后，USART_InitStructure就失去了作用。

`而在HAL库中`，同样是USART初始化结构体变量，我们要定义为全局变量。

UART_HandleTypeDef UART1_Handler;


                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

右键查看结构体成员

```
typedef struct
{
	USART_TypeDef                 *Instance;    /*!< UART registers base address       */
	UART_InitTypeDef              Init;         /*!< UART communication parameters     */
	uint8_t                       *pTxBuffPtr;  /*!< Pointer to UART Tx ansferBuffer   */
    uint16_t                      TxXferSize;   /*!< UART Tx Transfer size             */
	uint16_t                      TxXferCount;  /*!< UART Tx Transfer Counter          */
	uint8_t                       *pRxBuffPtr;  /*!< Pointer to UART Rx transfer Buffer*/
	uint16_t                      RxXferSize;   /*!< UART Rx Transfer size             */
	uint16_t                      RxXferCount;  /*!< UART Rx Transfer Counter          */ 
    DMA_HandleTypeDef             *hdmatx;      /*!< UART Tx DMA Handle parameters     */ 
	DMA_HandleTypeDef             *hdmarx;      /*!< UART Rx DMA Handle parameters     */
	HAL_LockTypeDef               Lock;         /*!< Locking object                    */
    __IO HAL_UART_StateTypeDef    State;        /*!< UART communication state          */
	__IO uint32_t                 ErrorCode;    /*!< UART Error code                   */
}UART_HandleTypeDef;

```

我们发现，与标准库不同的是，该成员不仅:

> 1、包含了之前标准库就有的六个成员（波特率，数据格式等），
>
> 2、还包含过采样、（发送或接收的）数据缓存、数据指针、串口 DMA 相关的变量、各种标志位等等要在整个项目流程中都要设置的各个成员。
>
> 该 UART1_Handler就被称为串口的句柄，它被贯穿整个USART收发的流程，比如开启中断：
> 

```c
HAL_UART_Receive_IT(&UART1_Handler, (u8 *)aRxBuffer, RXBUFFERSIZE);
```

比如后面要讲到的MSP与Callback回调函数：

```
void HAL_UART_MspInit(UART_HandleTypeDef *huart);
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
```

在这些函数中，只需要调用初始化时定义的句柄UART1_Handler就好。



## MSP函数

> MSP: MCU Specific Package 单片机的具体方案
>
> MSP是指和MCU相关的初始化，引用一下正点原子的解释，个人觉得说的很明白：

我们要初始化一个串口，**首先要设置和 MCU 无关的东西，例如波特率，奇偶校验，停止位等，这些参数设置和 MCU 没有任何关系**，可以使用 STM32F1，也可以是 STM32F2/F3/F4/F7上的串口。而一个串口设备它需要一个 MCU 来承载，例如用 STM32F4 来做承载，PA9 做为发送，PA10 做为接收，MSP 就是要初始化 STM32F4 的 PA9,PA10，配置这两个引脚。

> 所以 HAL驱动方式的初始化流程就是：

> HAL_USART_Init()—>HAL_USART_MspInit() ，先初始化与 MCU无关的`串口协议`，再初始化与 MCU 相关的`串口引脚`。
>

> 在HAL库中，几乎每初始化一个外设就需要设置该外设与单片机之间的联系，比如IO口，是否复用等等，可见，`HAL库`相对于`标准库`多了`MSP函数`之后，`移植性非常强`，但与此同时却增加了代码量和代码的嵌套层级。可以说各有利弊。
>

同样，MSP函数又可以配合句柄，达到非常强的移植性：

```
void HAL_UART_MspInit(UART_HandleTypeDef *huart);
```


入口参数仅仅需要`一个串口句柄`，这样有能看出句柄的方便。

## Callback函数

类似于MSP函数，个人认为Callback函数`主要帮助用户应用层的代码编写。`

还是以USART为例，在标准库中，串口中断了以后，我们要先在中断中判断是否是接收中断，然后读出数据，顺便清除中断标志位，然后再是对数据的处理，这样如果我们在一个中断函数中写这么多代码，就会显得很混乱：

```
void USART3_IRQHandler(void)                	//串口1中断服务程序
{
	u8 Res;
	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
	{
		Res =USART_ReceiveData(USART3);	//读取接收到的数据
		/*数据处理区*/
		}   		 
     } 
} 
```


而在HAL库中，进入串口中断后，直接由HAL库中断函数进行托管：

```
void USART1_IRQHandler(void)                	
{ 
	HAL_UART_IRQHandler(&UART1_Handler);	//调用HAL库中断处理公用函数
	/***************省略无关代码****************/	
}
```

HAL_UART_IRQHandler这个函数完成了判断是哪个中断（接收？发送？或者其他？），然后读出数据，保存至缓存区，顺便清除中断标志位等等操作。
比如我提前设置了，串口每接收五个字节，我就要对这五个字节进行处理。
在一开始我定义了一个串口接收缓存区：

```
//HAL库使用的串口接收缓冲,处理逻辑由HAL库控制，接收完这个数组就会调用HAL_UART_RxCpltCallback进行处理这个数组
//RXBUFFERSIZE=5

u8 aRxBuffer[RXBUFFERSIZE];
```



在初始化中，我在句柄里设置好了缓存区的地址，缓存大小（五个字节）

```
/*该代码在HAL_UART_Receive_IT函数中，初始化时会引用*/
	huart->pRxBuffPtr = pData;//aRxBuffer
    huart->RxXferSize = Size;//RXBUFFERSIZE
    huart->RxXferCount = Size;//RXBUFFERSIZE
```


则在接收数据中，每接收完五个字节，HAL_UART_IRQHandler才会执行一次Callback函数：

```
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
```

> 在这个Callback回调函数中，我们只需要对这接收到的五个字节（保存在aRxBuffer[]中）进行处理就好了，`完全不用再去手动清除标志位等操作`。
>
> 所以说Callback函数是一个`应用层代码的函数`，我们在一开始`只设置句柄里面的各个参数`，然后就等着HAL库把自己安排好的代码送到手中就可以了~

> 综上，就是HAL库的三个与标准库不同的地方之个人见解。
> 个人觉得从这三个小点就可以看出HAL库的可移植性之强大，`并且用户可以完全不去理会底层各个寄存器的操作`，代码也更有逻辑性。但与此带来的是复杂的代码量，`极慢的编译速度，略微低下的效率`。看怎么取舍了。

## HAL库编程方式
在 HAL 库中对外设模型进行了统一，支持三种编程方式：

轮询模式/阻塞模式
中断方式
DMA模式
以IIC为例，三种编程模式对应的函数如下：

1、轮询模式/阻塞模式

```
HAL_I2C_Master_Transmit()；  
HAL_I2C_Master_Receive()；  
HAL_I2C_Slave_Transmit()；  
HAL_I2C_Slave_Receive()
HAL_I2C_Mem_Write()；       
HAL_I2C_Mem_Read()；   
HAL_I2C_IsDeviceReady()
```

2、中断模式

```
HAL_I2C_Master_Transmit_IT()；    
HAL_I2C_Master_Receive_IT()；  
HAL_I2C_Slave_Transmit_IT()
HAL_I2C_Slave_Receive_IT()；    
HAL_I2C_Mem_Write_IT()；       
HAL_I2C_Mem_Read_IT()
```


3、DMA模式

```
HAL_I2C_Master_Transmit_DMA()；   
HAL_I2C_Master_Receive_DMA()；   
HAL_I2C_Slave_Transmit_DMA()；    
HAL_I2C_Slave_Receive_DMA()；    
HAL_I2C_Mem_Write_DMA()；     
HAL_I2C_Mem_Read_DMA()
```

# HAL库的结构与使用

## HAL结构

![image-20240401194430912](D:\A_Document\Routine_Document\实习\学习\image-20240401194430912.png)

![image-20240401194653494](D:\A_Document\Routine_Document\实习\学习\image-20240401194653494.png)

![image-20240401194841999](D:\A_Document\Routine_Document\实习\学习\image-20240401194841999.png)

![image-20240401204416141](D:\A_Document\Routine_Document\实习\学习\image-20240401204416141.png)

![image-20240401204558715](D:\A_Document\Routine_Document\实习\学习\image-20240401204558715.png)

CMSIS文件夹是ARM内核与STM32F1单片机硬件之间的底层协议

![image-20240401204819787](D:\A_Document\Routine_Document\实习\学习\image-20240401204819787.png)

![image-20240401204958069](D:\A_Document\Routine_Document\实习\学习\image-20240401204958069.png)

![image-20240401205019493](D:\A_Document\Routine_Document\实习\学习\image-20240401205019493.png)

![image-20240401205051785](D:\A_Document\Routine_Document\实习\学习\image-20240401205051785.png)

所谓学会某个功能就是学会三点

- 1，学会如果编写板级驱动程序
- 2，学会如何在板级驱动程序中调用HAL库中的功能函数
- 3，学会在main主函数中调用板级驱动程序

##  HAL库函数原理

![image-20240401205430841](D:\A_Document\Routine_Document\实习\学习\image-20240401205430841.png)



![image-20240401205724484](D:\A_Document\Routine_Document\实习\学习\image-20240401205724484.png)

![image-20240401205851126](D:\A_Document\Routine_Document\实习\学习\image-20240401205851126.png)

![image-20240401205953070](D:\A_Document\Routine_Document\实习\学习\image-20240401205953070.png)

![image-20240401210030076](D:\A_Document\Routine_Document\实习\学习\image-20240401210030076.png)

## HAL库的使用方法 

![image-20240401210225538](D:\A_Document\Routine_Document\实习\学习\image-20240401210225538.png)



# RCC时钟树

[第7集）RCC时钟与延时函数！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1jP4y1E7TJ?p=8&vd_source=c4b26319211bc9ccc5ba3a0a22916e39)

![image-20240402131413589](D:\A_Document\Routine_Document\实习\学习\image-20240402131413589.png)

# 驱动程序

## 简介

例如，LED驱动程序。用户编写驱动应用程序(main.c)-->用户编写驱动(xxx.c)-->HAL库-->底层HAL-->硬件

![image-20240402134227012](D:\A_Document\Routine_Document\实习\学习\image-20240402134227012.png)

![image-20240402134403228](D:\A_Document\Routine_Document\实习\学习\image-20240402134403228.png)

![image-20240402134540177](D:\A_Document\Routine_Document\实习\学习\image-20240402134540177.png)

![image-20240402135400404](D:\A_Document\Routine_Document\实习\学习\image-20240402135400404.png) 



## 闪存芯片+SPI驱动

![image-20240402135938079](D:\A_Document\Routine_Document\实习\学习\image-20240402135938079.png)



![image-20240402140449271](D:\A_Document\Routine_Document\实习\学习\image-20240402140449271.png)

![image-20240402141136478](D:\A_Document\Routine_Document\实习\学习\image-20240402141136478.png)

![image-20240402141051408](D:\A_Document\Routine_Document\实习\学习\image-20240402141051408.png)

## USB驱动

![image-20240402153512487](D:\A_Document\Routine_Document\实习\学习\image-20240402153512487.png)

![image-20240402153549224](D:\A_Document\Routine_Document\实习\学习\image-20240402153549224.png)

![image-20240402153724088](D:\A_Document\Routine_Document\实习\学习\image-20240402153724088.png)

![image-20240402154305794](D:\A_Document\Routine_Document\实习\学习\image-20240402154305794.png)

## RS485

![image-20240402155947690](D:\A_Document\Routine_Document\实习\学习\image-20240402155947690.png)

 ![image-20240402160042785](D:\A_Document\Routine_Document\实习\学习\image-20240402160042785.png)	

![image-20240402160117930](D:\A_Document\Routine_Document\实习\学习\image-20240402160117930.png)

## CAN驱动

[第19集）CAN总线驱动程序！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1jP4y1E7TJ?p=20&vd_source=c4b26319211bc9ccc5ba3a0a22916e39)

![image-20240402160614661](D:\A_Document\Routine_Document\实习\学习\image-20240402160614661.png)

## 蓝牙驱动

没有wifi有扩展性，但具有低成本低功耗。

![image-20240402161853657](D:\A_Document\Routine_Document\实习\学习\image-20240402161853657.png)

![image-20240402171205558](D:\A_Document\Routine_Document\实习\学习\image-20240402171205558.png)

![image-20240402171258889](D:\A_Document\Routine_Document\实习\学习\image-20240402171258889.png)

![image-20240402162026048](D:\A_Document\Routine_Document\实习\学习\image-20240402162026048.png)

![image-20240402162102402](D:\A_Document\Routine_Document\实习\学习\image-20240402162102402.png)

![image-20240402162115135](D:\A_Document\Routine_Document\实习\学习\image-20240402162115135.png)

### 蓝牙模块`唤醒函数`

![image-20240402162406023](D:\A_Document\Routine_Document\实习\学习\image-20240402162406023.png)

### 蓝牙`print函数`

![image-20240402162442171](D:\A_Document\Routine_Document\实习\学习\image-20240402162442171.png)

### BT.h

借用了UART函数

![image-20240402162543598](D:\A_Document\Routine_Document\实习\学习\image-20240402162543598.png)

![image-20240402162644396](D:\A_Document\Routine_Document\实习\学习\image-20240402162644396.png)

### 蓝牙模块`接收处理程序`

![image-20240402164246358](D:\A_Document\Routine_Document\实习\学习\image-20240402164246358.png)

### 蓝牙AT指令

![image-20240402164625959](D:\A_Document\Routine_Document\实习\学习\image-20240402164625959.png)

![image-20240402164719066](D:\A_Document\Routine_Document\实习\学习\image-20240402164719066.png)

![image-20240402164747022](D:\A_Document\Routine_Document\实习\学习\image-20240402164747022.png)

![image-20240402164838365](D:\A_Document\Routine_Document\实习\学习\image-20240402164838365.png)

![image-20240402164954548](D:\A_Document\Routine_Document\实习\学习\image-20240402164954548.png)

应用驱动程序：发送AT指令到蓝牙模块

![image-20240402165138112](D:\A_Document\Routine_Document\实习\学习\image-20240402165138112.png)

AT指令是应用于[终端设备](https://baike.baidu.com/item/终端设备/643738?fromModule=lemma_inlink)与PC应用之间的连接与通信的指令。AT 即Attention。每个AT[命令行](https://baike.baidu.com/item/命令行/196110?fromModule=lemma_inlink)中只能包含一条AT指令；对于AT指令的发送，除AT两个字符外，最多可以接收1056个字符的长度（包括最后的空字符）。`AT命令集可用于控制&调测设备、通信模块入网等`。本文为大家介绍NB-IoT常用的AT命令集及其调测工具。

![img](D:\A_Document\Routine_Document\实习\学习\v2-f9d8ad63f1b733546d1374dee3a33395_720w.webp)

蓝牙模块回复数据的处理程序

![image-20240402165434356](D:\A_Document\Routine_Document\实习\学习\image-20240402165434356.png)

## WIFI模块原理与AT指令

![image-20240402170841406](D:\A_Document\Routine_Document\实习\学习\image-20240402170841406.png)

让WIFI模块与USART1串口实现透传

利用串口助手软件与WIFI模块收发AT指令

![image-20240402171043470](D:\A_Document\Routine_Document\实习\学习\image-20240402171043470.png)

![image-20240402171349475](D:\A_Document\Routine_Document\实习\学习\image-20240402171349475.png)

![image-20240402171422722](D:\A_Document\Routine_Document\实习\学习\image-20240402171422722.png)

![image-20240402171445752](D:\A_Document\Routine_Document\实习\学习\image-20240402171445752.png)

![image-20240402171505834](D:\A_Document\Routine_Document\实习\学习\image-20240402171505834.png)

![image-20240402171522265](D:\A_Document\Routine_Document\实习\学习\image-20240402171522265.png)

![image-20240402171556046](D:\A_Document\Routine_Document\实习\学习\image-20240402171556046.png)

![image-20240402172209798](D:\A_Document\Routine_Document\实习\学习\image-20240402172209798.png)

###  wifi+AT指令

![image-20240402172342224](D:\A_Document\Routine_Document\实习\学习\image-20240402172342224.png)

![image-20240402172413138](D:\A_Document\Routine_Document\实习\学习\image-20240402172413138.png)

![image-20240402172424288](D:\A_Document\Routine_Document\实习\学习\image-20240402172424288.png)

### wifi模块中的TCP AT指令

![image-20240402172535525](D:\A_Document\Routine_Document\实习\学习\image-20240402172535525.png)

![image-20240402172557819](D:\A_Document\Routine_Document\实习\学习\image-20240402172557819.png)

### WIFI连接方式

![image-20240402192537607](D:\A_Document\Routine_Document\实习\学习\image-20240402192537607.png)

![image-20240402192801008](D:\A_Document\Routine_Document\实习\学习\image-20240402192801008.png)

![image-20240402192813255](D:\A_Document\Routine_Document\实习\学习\image-20240402192813255.png) 

![image-20240402192953901](D:\A_Document\Routine_Document\实习\学习\image-20240402192953901.png)

![image-20240402193117958](D:\A_Document\Routine_Document\实习\学习\image-20240402193117958.png)

### WIFI模块控制单片机

发送至wifi模块函数

![image-20240402193842890](D:\A_Document\Routine_Document\实习\学习\image-20240402193842890.png)

wifi模块接收处理函数

![image-20240402194033938](D:\A_Document\Routine_Document\实习\学习\image-20240402194033938.png)

![image-20240402194318346](D:\A_Document\Routine_Document\实习\学习\image-20240402194318346.png)

应用程序

![image-20240402194929190](D:\A_Document\Routine_Document\实习\学习\image-20240402194929190.png)

![image-20240402195021234](D:\A_Document\Routine_Document\实习\学习\image-20240402195021234.png)

## 物联网平台

![image-20240402195136224](D:\A_Document\Routine_Document\实习\学习\image-20240402195136224.png)

![image-20240402195217040](D:\A_Document\Routine_Document\实习\学习\image-20240402195217040.png)

![image-20240402195340520](D:\A_Document\Routine_Document\实习\学习\image-20240402195340520.png)

![image-20240402195349929](D:\A_Document\Routine_Document\实习\学习\image-20240402195349929.png)

![image-20240402195505212](D:\A_Document\Routine_Document\实习\学习\image-20240402195505212.png)

### 框架介绍

![image-20240402200055916](D:\A_Document\Routine_Document\实习\学习\image-20240402200055916.png)

![image-20240402200600773](D:\A_Document\Routine_Document\实习\学习\image-20240402200600773.png)

![image-20240402200656712](D:\A_Document\Routine_Document\实习\学习\image-20240402200656712.png)

![image-20240402200804546](D:\A_Document\Routine_Document\实习\学习\image-20240402200804546.png)

![image-20240402200901023](D:\A_Document\Routine_Document\实习\学习\image-20240402200901023.png)

### 原理

![image-20240402201234526](D:\A_Document\Routine_Document\实习\学习\image-20240402201234526.png)

![image-20240402201306007](D:\A_Document\Routine_Document\实习\学习\image-20240402201306007.png)

![image-20240402201347793](D:\A_Document\Routine_Document\实习\学习\image-20240402201347793.png)

 ![image-20240402201553984](D:\A_Document\Routine_Document\实习\学习\image-20240402201553984.png)

![image-20240402201844718](D:\A_Document\Routine_Document\实习\学习\image-20240402201844718.png)

### 代码部分

![image-20240402201907342](D:\A_Document\Routine_Document\实习\学习\image-20240402201907342.png)

![image-20240402201949676](D:\A_Document\Routine_Document\实习\学习\image-20240402201949676.png)

WIFI模块连到路由器

![image-20240402202037121](D:\A_Document\Routine_Document\实习\学习\image-20240402202037121.png)

WIFI模块通过TCP练到服务器

![image-20240402202106907](D:\A_Document\Routine_Document\实习\学习\image-20240402202106907.png)

主体订阅函数

![image-20240402202217964](D:\A_Document\Routine_Document\实习\学习\image-20240402202217964.png)

主体发布函数

![image-20240402202235516](D:\A_Document\Routine_Document\实习\学习\image-20240402202235516.png)

上面都是调用，自己实现部分：

![image-20240402202323378](D:\A_Document\Routine_Document\实习\学习\image-20240402202323378.png)

![image-20240402202333896](D:\A_Document\Routine_Document\实习\学习\image-20240402202333896.png)

连接AP/TCP/MQTT(云平台)

![image-20240402202339518](D:\A_Document\Routine_Document\实习\学习\image-20240402202339518.png)

心跳包：保持程序在线的检测

![image-20240402202422988](D:\A_Document\Routine_Document\实习\学习\image-20240402202422988.png)

接收云平台消息：

![image-20240402202507987](D:\A_Document\Routine_Document\实习\学习\image-20240402202507987.png)

判断消息内容是不是控制关键字：

![image-20240402202602795](D:\A_Document\Routine_Document\实习\学习\image-20240402202602795.png)

按键按下操作

![image-20240402202723266](D:\A_Document\Routine_Document\实习\学习\image-20240402202723266.png) 



# 功能实现

整个系统能够实现：
1、[STM32](https://so.csdn.net/so/search?q=STM32&spm=1001.2101.3001.7020)读取传感器的温湿度十六进制数据并转化为十进制数值
2、使用[ESP8266](https://so.csdn.net/so/search?q=ESP8266&spm=1001.2101.3001.7020)模块将数据使用AT指令通过MQTT协议传输到阿里云服务中并展示出来



# STM32与ESP8266连接

| 指令名           | 响应                       | 含义                       |
| ---------------- | -------------------------- | -------------------------- |
| AT               | OK                         | 测试指令                   |
| AT+CWMODE=<mode> | OK                         | 设置应用模式（需重启生效） |
| AT+CWMODE?       | +CWMODE:<mode>             | 获得当前应用模式           |
| AT+CWLAP         | +CWLAP:<ecn>,<ssid>,<rssi> | 返回目前的AP列表           |

| AT+CIPSTART=<type>,<addr>,<port> | OK   | 建立TCP/UDP连接  |
| -------------------------------- | ---- | ---------------- |
| AT+CIPMUX=<mode>                 | OK   | 是否启用多连接   |
| AT+CIPSEND=<param>               | OK   | 发送数据         |
| AT+CIPMODE=<mode>                | OK   | 是否进入透传模式 |

需要补充几点：

1、ESP8266的应用模式：ESP266支撑单AP模式、单STA模式和混合模式。简单的来说就是：

- **AP：可以将ESP8266作为热点，可以让其他的设备连接上它；**
- **STA：可以连接上当前环境下的WIFI热点。**

2、什么是透传模式？

透传就是指不需要关心wifi协议是如何实现的。所需要做的就是A通过串口发数据，B通过串口收数据，整个过程中A串口和B串口就像是用导线直接连接起来了一样。`则对于开发人员来看，就是完全透明的。`

更简单地理解就是：

如果不开启透传模式，我们怎么发送数据呢？在每次发送数据前都必须先发送指令AT+CIPSEND=<param>，例如：

> AT+CIPSEND=4
>
> OK

>                //在 > 后面输入要上传的数据
>                但是一旦开启了透传模式，我们就不需要在每次发送数据前都发送指令AT+CIPSEND=<param>了，只需要发送一次AT+CIPSEND，之后发送的所有内容全部当成是数据了！

但是这也存在一个问题，要是我后来又想发送命令了，但是却也当成是数据发送过去了。这可怎么办？

这就要退出透传模式了。怎么退出，发送数据"+++"就可以了。注意：此时“+++”后面，不接“发送新行”！

## WIFI模块的使用

ESP8266的一般使用顺序
这里的“一般”指的是：ESP8266连接当前环境的热点，与服务器建立TCP连接，传输数据。

```
AT+CWMODE=1：设置工作模式（STA模式）
AT+RST：模块重启（生效工作模式）
AT+CWJAP="111","11111111"：连接当前环境的WIFI热点（热点名，密码）
AT+CIPMUX=0：设置单路连接模式
AT+CIPSTART="TCP","xxx.xxx.xxx.xxx",xxxx：建立TCP连接
AT+CIPMODE=1：开启透传模式
AT+CIPSEND：透传模式下，传输数据
+++：退出透传模式

```



#### ESP8266的封装代码

关于与单片机的引脚连接：ESP8266与USART3（引脚PB10、PB11）连接。

首先是USART的配置：

```cpp
#include "delay.h"
#include "usart3.h"
#include "stdarg.h"	 	 
#include "stdio.h"	 	 
#include "string.h"	 
#include "timer.h" 
 
//串口接收缓存区 	
u8 USART3_RX_BUF[USART3_MAX_RECV_LEN]; 				//接收缓冲,最大USART3_MAX_RECV_LEN个字节.
u8  USART3_TX_BUF[USART3_MAX_SEND_LEN]; 			//发送缓冲,最大USART3_MAX_SEND_LEN字节
 
//通过判断接收连续2个字符之间的时间差不大于10ms来决定是不是一次连续的数据.
//如果2个字符接收间隔超过10ms,则认为不是1次连续数据.也就是超过10ms没有接收到
//任何数据,则表示此次接收完毕.
//接收到的数据状态
//[15]:0,没有接收到数据;1,接收到了一批数据.
//[14:0]:接收到的数据长度
vu16 USART3_RX_STA=0;   	
 
 
void USART3_IRQHandler(void)
{
	u8 res;	      
	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)//接收到数据
	{	 
		res =USART_ReceiveData(USART3);		 
		if((USART3_RX_STA&(1<<15))==0)//接收完的一批数据,还没有被处理,则不再接收其他数据
		{ 
			if(USART3_RX_STA<USART3_MAX_RECV_LEN)	//还可以接收数据
			{
				TIM_SetCounter(TIM7,0);//计数器清空          				//计数器清空
				if(USART3_RX_STA==0) 				//使能定时器7的中断 
				{
					TIM_Cmd(TIM7,ENABLE);//使能定时器7
				}
				USART3_RX_BUF[USART3_RX_STA++]=res;	//记录接收到的值	 
			}else //超过缓冲区大小
			{
				USART3_RX_STA|=1<<15;				//强制标记接收完成
			} 
		}
	}  				 											 
}   
 
 
//初始化IO 串口3
//pclk1:PCLK1时钟频率(Mhz)
//bound:波特率	  
void usart3_init(u32 bound)
{  
 
	NVIC_InitTypeDef NVIC_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
 
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);	// GPIOB时钟
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3,ENABLE); //串口3时钟使能
 
 	USART_DeInit(USART3);  //复位串口3
		 //USART3_TX   PB10
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //PB10
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
  GPIO_Init(GPIOB, &GPIO_InitStructure); //初始化PB10
   
    //USART3_RX	  PB11
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
  GPIO_Init(GPIOB, &GPIO_InitStructure);  //初始化PB11
	
	USART_InitStructure.USART_BaudRate = bound;//波特率一般设置为9600;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
  
	USART_Init(USART3, &USART_InitStructure); //初始化串口	3
  
 
	USART_Cmd(USART3, ENABLE);                    //使能串口 
	
	//使能接收中断
  USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);//开启中断   
	
	//设置中断优先级
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2 ;//抢占优先级3
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
	
	
	TIM7_Int_Init(1000-1,7200-1);		//10ms中断
	USART3_RX_STA=0;		//清零
	TIM_Cmd(TIM7,DISABLE);			//关闭定时器7
 
}
 
//串口3,printf 函数
//确保一次发送数据不超过USART3_MAX_SEND_LEN字节
void u3_printf(char* fmt,...)  
{  
	u16 i,j; 
	va_list ap; 
	va_start(ap,fmt);
	vsprintf((char*)USART3_TX_BUF,fmt,ap);
	va_end(ap);
	i=strlen((const char*)USART3_TX_BUF);		//此次发送数据的长度
	for(j=0;j<i;j++)							//循环发送数据
	{
	  while(USART_GetFlagStatus(USART3,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕   
		USART_SendData(USART3,USART3_TX_BUF[j]); 
	} 
}
```

### 开启定时器

由于在USART3中是通过判断接收连续2个字符之间的时间差不大于10ms来决定是不是一次连续的数据，而10ms怎么定呢？通过定时器来的，所以我们需要开启定时器

```c
#include "timer.h"

extern vu16 USART3_RX_STA;

//定时器7中断服务程序		    
void TIM7_IRQHandler(void)
{ 	
	if (TIM_GetITStatus(TIM7, TIM_IT_Update) != RESET)//是更新中断
	{	 			   
		USART3_RX_STA|=1<<15;	//标记接收完成
		TIM_ClearITPendingBit(TIM7, TIM_IT_Update  );  //清除TIM7更新中断标志    
		TIM_Cmd(TIM7, DISABLE);  //关闭TIM7 
	}	    
}

//通用定时器7中断初始化，这里时钟选择为APB1的2倍
//arr：自动重装值 psc：时钟预分频数
//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.
//Ft=定时器工作频率,单位:Mhz 
//通用定时器中断初始化 
void TIM7_Int_Init(u16 arr,u16 psc)
{	
	NVIC_InitTypeDef NVIC_InitStructure;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);//TIM7时钟使能    

    //定时器TIM7初始化
    TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	
    TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
    TIM_TimeBaseInit(TIM7, &TIM_TimeBaseStructure); //根据指定的参数初始化TIMx的时间基数单位

    TIM_ITConfig(TIM7,TIM_IT_Update,ENABLE ); //使能指定的TIM7中断,允许更新中断

    TIM_Cmd(TIM7,ENABLE);//开启定时器7

    NVIC_InitStructure.NVIC_IRQChannel = TIM7_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0 ;//抢占优先级0
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;		//子优先级2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
    NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
    }
```



### 向ESP8266传输数据了

这两个都完成了之后，就可以向ESP8266传输数据了:


```C
#include "esp8266.h"
#include "string.h"
#include "usart.h"
#include "usart3.h"
#include "stm32f10x.h"
#include "sys.h" 
#include "delay.h"

//ESP8266模块和PC进入透传模式
void esp8266_start_trans(void)
{
	//设置工作模式 1：station模式   2：AP模式  3：兼容 AP+station模式
	esp8266_send_cmd("AT+CWMODE=1","OK",50);
	
   //让Wifi模块重启的命令
esp8266_send_cmd("AT+RST","ready",20);

delay_ms(1000);         //延时3S等待重启成功
delay_ms(1000);
delay_ms(1000);
delay_ms(1000);

//让模块连接上自己的路由
while(esp8266_send_cmd("AT+CWJAP=\"111\",\"11111111\"","WIFI GOT IP",600));

//=0：单路连接模式     =1：多路连接模式
esp8266_send_cmd("AT+CIPMUX=0","OK",20);

//建立TCP连接  这四项分别代表了 要连接的ID号0~4   连接类型  远程服务器IP地址   远程服务器端口号
while(esp8266_send_cmd("AT+CIPSTART=\"TCP\",\"xxx.xxx.xxx.xxx\",xxxx","CONNECT",200));

//是否开启透传模式  0：表示关闭 1：表示开启透传
esp8266_send_cmd("AT+CIPMODE=1","OK",200);

//透传模式下 开始发送数据的指令 这个指令之后就可以直接发数据了
esp8266_send_cmd("AT+CIPSEND","OK",50);
    }

//ESP8266退出透传模式   返回值:0,退出成功;1,退出失败
//配置wifi模块，通过想wifi模块连续发送3个+（每个+号之间 超过10ms,这样认为是连续三次发送+）
u8 esp8266_quit_trans(void)
{
	u8 result=1;
	u3_printf("+++");
	delay_ms(1000);					//等待500ms太少 要1000ms才可以退出
	result=esp8266_send_cmd("AT","OK",20);//退出透传判断.
	if(result)
		printf("quit_trans failed!");
	else
		printf("quit_trans success!");
	return result;
}


//向ESP8266发送命令
//cmd:发送的命令字符串;ack:期待的应答结果,如果为空,则表示不需要等待应答;waittime:等待时间(单位:10ms)
//返回值:0,发送成功(得到了期待的应答结果);1,发送失败
u8 esp8266_send_cmd(u8 *cmd,u8 *ack,u16 waittime)
{
	u8 res=0; 
	USART3_RX_STA=0;
	u3_printf("%s\r\n",cmd);	//发送命令
	if(ack&&waittime)		//需要等待应答
	{
		while(--waittime)	//等待倒计时
		{
			delay_ms(10);
			if(USART3_RX_STA&0X8000)//接收到期待的应答结果
			{
				if(esp8266_check_cmd(ack))
				{
					printf("ack:%s\r\n",(u8*)ack);
					break;//得到有效数据 
				}
					USART3_RX_STA=0;
			} 
		}
		if(waittime==0)res=1; 
	}
	return res;
} 


//ESP8266发送命令后,检测接收到的应答
//str:期待的应答结果
//返回值:0,没有得到期待的应答结果;其他,期待应答结果的位置(str的位置)
u8* esp8266_check_cmd(u8 *str)
{
	char *strx=0;
	if(USART3_RX_STA&0X8000)		//接收到一次数据了
	{ 
		USART3_RX_BUF[USART3_RX_STA&0X7FFF]=0;//添加结束符
		strx=strstr((const char*)USART3_RX_BUF,(const char*)str);
	} 
	return (u8*)strx;
}

//向ESP8266发送数据
//cmd:发送的命令字符串;waittime:等待时间(单位:10ms)
//返回值:发送数据后，服务器的返回验证码
u8* esp8266_send_data(u8 *cmd,u16 waittime)
{
	char temp[5];
	char *ack=temp;
	USART3_RX_STA=0;
	u3_printf("%s",cmd);	//发送命令
	if(waittime)		//需要等待应答
	{
		while(--waittime)	//等待倒计时
		{
			delay_ms(10);
			if(USART3_RX_STA&0X8000)//接收到期待的应答结果
			{
				USART3_RX_BUF[USART3_RX_STA&0X7FFF]=0;//添加结束符
				ack=(char*)USART3_RX_BUF;
				printf("ack:%s\r\n",(u8*)ack);
				USART3_RX_STA=0;
				break;//得到有效数据 
			} 
		}
	}
	return (u8*)ack;
} 


```
# STM32与ZigBee

## 1.所用的资源

1.两个[Zigbee](https://so.csdn.net/so/search?q=Zigbee&spm=1001.2101.3001.7020)透传模块
2.两块32板（我手上的是VET6和RCT6的两块板子），其它的板子也可以，不过注意一下启动文件对应

3.颗粒物传感器

## 2.Zigbee模块简介

> 根据配置按键配置工作模式就行了，直接连就可以

DL-22无线串口模块

![在这里插入图片描述](D:\A_Document\Routine_Document\实习\学习\e1193ec2dddc4016af9dfc2a8e3f1cb5.png)

1. 工作模式分为点对点和广播模式
   点对点模式，要设置一个发送端，一个接收端，根据它说明书进行设置就好，还需要设置相同的信道，信道就是与传输数据的通道，不同的信道不会相互干扰
2. 广播模式，所有的Zigbee模块都在同一个信道，任何一个模块发出的数据都可以被其它模块接收
   我这里采用的是点对点模式，根据说明书已设置好发送与接收
3. STM32板上用到的资源
   - 发送端32板：用到三个USART串口，串口1用于检验单独节点传感器数据是否采集成功，与串口助手通信，在确保传感器数据采集ok的情况下也可以不用，串口2用于与采集传感器数据，串口3用来连接Zigbee模块。
   - 接收端32板：用到两个USART串口，串口1用于与串口助手通信，串口2用于连接Zigbee模块。
   - 我这里串口对应的板子引脚
     串口1：PA9 PA10
     串口2: PA2 PA3
     串口3: PB10 PB11

## 代码部分

1. 在之前记录的串口通信博客的基础上。
2.Zigbee模块其实就是透传作用，发送端通过串口2采集颗粒物传感器数据到单片机内，通过串口3传给Zigbee模块，两个Zigebee模块通信，接收端Zigbee模块通过串口2将接收的数据传到板内，再通过串口1与串口助手进行通信。所以关键的地方就在发送端的串口2接收传感器数据完成后，把数据通过串口3发送到Zigbee模块，`所以需要在串口二的中断函数里面加入串口3发送数据的命令。`

![在这里插入图片描述](D:\A_Document\Routine_Document\实习\学习\89d15d6aa1ed4502a06f6a3d5285fb67.png)

### 串口2中断(传感器->32)

```c

#include "stm32f10x.h"
#include "uart2.h"
#include "sys.h"
#include "usart.h"
#include "uart3.h"

//
//加入以下代码,支持printf函数,应该也可以不加了，串口一已经加了  
#if 1
#pragma import(__use_no_semihosting)             
//标准库需要的支持函数                 
struct __FILE 
{ 
	int handle; 
}; 
#endif 


void uart2_init(u32 bound)   //初始化串口2，函数的参数是波特率
{
  
   //GPIO端口设置
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
     
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,  ENABLE);//使能GPIOA时钟
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);//使能USART2时钟
   //USART_DeInit(USART2);  //复位串口2
    //USART2_TX   GPIOA.2
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //PA.2
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    //复用推挽输出
  GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.2
   
  //USART2_RX      GPIOA.3初始化
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA3
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
  GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.3 
 //Usart2 NVIC 配置
    NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2 ;//抢占优先级3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;        //子优先级3
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;            //IRQ通道使能
    NVIC_Init(&NVIC_InitStructure);    //根据指定的参数初始化VIC寄存器
 
  //USART2 初始化设置
    USART_InitStructure.USART_BaudRate = bound;//串口波特率
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
    USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
    USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;    //收发模式
    USART_Init(USART2, &USART_InitStructure); //初始化串口2
    USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启串口接受中断
    USART_Cmd(USART2, ENABLE);                    //使能串口2
    USART_ClearFlag(USART2, USART_FLAG_TC);
}

//功能：串口2中断服务程序，接收到数据会进入这个函数
//参数：无
//返回：无

 u8 USART_RX_BUF[10];//定义接收数组，看传感器返回的有多少字节数据
 u8 USART_RX_STA=0;//数组标志位，如第0位、第一位
 static char  start=0;  //开始接收数据标志位

void USART2_IRQHandler(void)
{
  u8 Res=0;//定义一个数来接收每次读取的数据
   if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)  //接收中断，每一个字节都会中断一次
    {
        Res =USART_ReceiveData(USART2);	//读取接收到的字节数据
        //接收数据时不要随便加入占用时间的命令，如串口打印，会影响下面数据字节的接收
      	if(Res == 0xFF) //如果接收的第一位数据是0XFF（这个是查看传感器的手册得知的,这里相当于进行校验）
        {
             start=1;   //开始接收数据标志位，一旦第一个接收正确，就就继续向下接收
        }

        if(start== 1)
        {
            USART_RX_BUF[USART_RX_STA] = Res ; //把接收到的数据存到数组里面		
            USART_RX_STA++;//数组标志位加1
            if(USART_RX_STA >= 10 && (USART_RX_BUF[1]==0X01))//这里还校验了接收的第二个数据
                {
                 printf("PM2.5:%d\n",USART_RX_BUF[3]);//通过                         串口1打印接收数组里的数据	
                    							  	USART_SendData(USART3,USART_RX_BUF[3]);	//将数据通过串口3发出							  uart3_send_buff(USART_RX_BUF,10);
                    USART_RX_STA=0;//重新开始接收   
                    USART_RX_BUF[0] = 0;
				              start=0;
                }
        } 
    
	}
}		
```

### 串口3中断(32->ZB)

```c
#include "uart3.h"
#include "stm32f10x.h"
#include "uart2.h"
#include "sys.h"
#include "usart.h"

//
//加入以下代码,支持printf函数,应该也可以不加了，串口一已经加了  
#if 1
#pragma import(__use_no_semihosting)             
//标准库需要的支持函数                 
struct __FILE 
{ 
	int handle; 
}; 
#endif 


void uart3_init(u32 bound)   //初始化串口2，函数的参数是波特率
{
   
    USART_InitTypeDef USART_InitStructure;  
    NVIC_InitTypeDef NVIC_InitStructure;   
    GPIO_InitTypeDef GPIO_InitStructure;    //声明一个结构体变量，用来初始化GPIO  
    //使能串口的RCC时钟  
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE); //使能UART3所在GPIOB的时钟  
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);  
 
    //串口使用的GPIO口配置  
    // Configure USART3 Tx (PB.10) as alternate function push-pull  
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;  
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  
    GPIO_Init(GPIOB, &GPIO_InitStructure); 
 
    // Configure USART3 Rx (PB.11) as input floating    
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;  
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  
    GPIO_Init(GPIOB, &GPIO_InitStructure);   
 
    //串口中断配置  
    //Configure the NVIC Preemption Priority Bits     
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
 
    // Enable the USART3 Interrupt   
    NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;   
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;        //子优先级3
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  
    NVIC_Init(&NVIC_InitStructure);  
 
    //配置串口  
    USART_InitStructure.USART_BaudRate = bound;  
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;  
    USART_InitStructure.USART_StopBits = USART_StopBits_1;  
    USART_InitStructure.USART_Parity = USART_Parity_No;  
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;  
 
    // Configure USART3   
    USART_Init(USART3, &USART_InitStructure);//配置串口3 
    // Enable USART3 Receive interrupts 使能串口接收中断  
    USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);  
    // Enable the USART3   
    USART_Cmd(USART3, ENABLE);//使能串口3       
      
}

//功能：串口3中断服务程序，接收到数据会进入这个函数
//参数：无
//返回：无
 
 u8 USART_RX_BUF3[9];//定义接收数组，看传感器返回的有多少字节数据
 u8 USART_RX_STA3=0;//数组标志位，如第0位、第一位
 static char  start3=0;  //开始接收数据标志位

void USART3_IRQHandler(void)
{
  u8 Res=0;//定义一个数来接收每次读取的数据
   if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)  //接收中断，每一个字节都会中断一次
    {
			
        Res =USART_ReceiveData(USART3);	//读取接收到的字节数据
        //接收数据时不要随便加入占用时间的命令，如串口打印，会影响下面数据字节的接收
      
			if(Res == 0xFF) //如果接收的第一位数据是0XFF（这个是查看传感器的手册得知的,这里相当于进行校验）
            {
                 start3=1;   //开始接收数据标志位，一旦第一个接收正确，就就继续向下接收
            }

            if(start3== 1)
            {
                USART_RX_BUF3[USART_RX_STA3] = Res ; //把接收到的数据存到数组里面		
                USART_RX_STA3++;//数组标志位加1
                if(USART_RX_STA3 >= 9 && (USART_RX_BUF3[1]==0x86))//这里还校验了接收的第二个数据
                    {
                        printf("PM2.5:%d\n",USART_RX_BUF3[4]);//通过串口1打印接收数组里的数据
                        USART_RX_STA3=0;//重新开始接收   
                        USART_RX_BUF3[0] = 0;
					              start3=0;
                    }
            } 
        
		}
	}		

	
	

//功能：串口3发送一个字符
//参数：temp发送的字符
//返回：无
void uart3_send_char(u8 temp)
{
    USART_SendData(USART3,(u8)temp);      
    while(USART_GetFlagStatus(USART3,USART_FLAG_TXE)==RESET);
}

//功能：串口1发送字符串
//参数：buf发送的字符串,len字符串的长度
//返回：无
void uart3_send_buff(u8* buf,u32 len)      
{
    u32 i;

    for(i=0;i<len;i++)
        uart3_send_char(buf[i]);
} 

```

### 温湿度模块驱动

```c
#include "dht11.h"
#include "delay.h"
      
//复位DHT11
void DHT11_Rst(void)	   
{                 
	DHT11_IO_OUT(); 	//SET OUTPUT
    DHT11_DQ_OUT=0; 	//拉低DQ
    delay_ms(20);    	//拉低至少18ms
    DHT11_DQ_OUT=1; 	//DQ=1 
	delay_us(30);     	//主机拉高20~40us
}
//等待DHT11的回应
//返回1:未检测到DHT11的存在
//返回0:存在
u8 DHT11_Check(void) 	   
{   
	u8 retry=0;
	DHT11_IO_IN();//SET INPUT	 
    while (DHT11_DQ_IN&&retry<100)//DHT11会拉低40~80us
	{
		retry++;
		delay_us(1);
	};	 
	if(retry>=100)return 1;
	else retry=0;
    while (!DHT11_DQ_IN&&retry<100)//DHT11拉低后会再次拉高40~80us
	{
		retry++;
		delay_us(1);
	};
	if(retry>=100)return 1;	    
	return 0;
}
//从DHT11读取一个位
//返回值：1/0
u8 DHT11_Read_Bit(void) 			 
{
 	u8 retry=0;
	while(DHT11_DQ_IN&&retry<100)//等待变为低电平
	{
		retry++;
		delay_us(1);
	}
	retry=0;
	while(!DHT11_DQ_IN&&retry<100)//等待变高电平
	{
		retry++;
		delay_us(1);
	}
	delay_us(40);//等待40us
	if(DHT11_DQ_IN)return 1;
	else return 0;		   
}
//从DHT11读取一个字节
//返回值：读到的数据
u8 DHT11_Read_Byte(void)    
{        
    u8 i,dat;
    dat=0;
	for (i=0;i<8;i++) 
	{
   		dat<<=1; 
	    dat|=DHT11_Read_Bit();
    }						    
    return dat;
}

//从DHT11读取一次数据
//temp:温度值(范围:0~50°)
//humi:湿度值(范围:20%~90%)
//返回值：0,正常;1,读取失败
u8 DHT11(u8 *temp,u8 *humi)    
{        
 	u8 buf[5];
	u8 i;
	DHT11_Rst();
	if(DHT11_Check()==0)
	{
		for(i=0;i<5;i++)//读取40位数据
		{
			buf[i]=DHT11_Read_Byte();
		}
		if((buf[0]+buf[1]+buf[2]+buf[3])==buf[4])
		{
			*humi=buf[0];
			*temp=buf[2];
		}
	}else return 1;
	return 0;	    
}
//初始化DHT11的IO口 DQ 同时检测DHT11的存在
//返回1:不存在
//返回0:存在    	 
u8 DHT11_Init(void)
{	 
 	GPIO_InitTypeDef  GPIO_InitStructure;
 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);	 //使能PB口时钟 

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;				//PB9 推挽输出
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		  
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);

    GPIO_SetBits(GPIOB,GPIO_Pin_9);    //输出1

    DHT11_Rst();  //复位DHT11
    return DHT11_Check();//等待DHT11的回应
 }
```

# ZigBee组网

## zigbee组网和入网流程概述

zigbee组建网络以及设备加入网络，一般分为以下几个步骤：

- 协调器组建网络

- 触发打开协调器入网开关

- 触发终端设备尝试加入网络

## Zigbee3.0组建网络

组建一个完整的zigbee网络包括两个步骤：

1. 创建zigbee网络

2. 节点（路由器或终端）加入网络

其中节点加入网络有两种方式：通过协调器入网、通过父节点入网

### 2.1 创建zigbee网络

#### 2.1.1 创建zigbee网络对节点的要求
Zigbee网络的创建由协调器发起，任何一个zigbee节点要组建一个网络必须要同时满足以下两点要求：

1) 节点是FFD（全功能设备，也就是网络中的路由）节点，具备zigbee协调器的能力；

2. 节点还没有加入其他网络，当节点已经加入其他网络时，该节点只能作为其他网络的子节点，因为一个zigbee网络中只能有一个协调器。

#### 2.1.2 网络创建流程

1. 确定网络协调器，首先判断节点是否是FFD节点，接着判断此FFD节点是否在其他网络里或者网络里是否已经存在协调器。

2. 通过主动扫描，发送一个信标请求命令（Beacon request command），然后设置一个扫描期限，如果在扫描期限内都没有检测到信标（beacon），那么就认为FFD在其信号范围内没有协调器，此时可以建立zigbee网络，并作为网络协调器不断地产生信标并广播出去。

3. 信道扫描过程，包括能量扫描和主动扫描两个过程

   - 首先对指定的信道或者默认的信道进行能量检测，以递增的方式对所测量的能量值进行信道排序，丢弃能量值超出可允许能量水平的信道，选择在合法能量水平的信道并标注这些信道是可用信道。

   - 接着进行主动扫描，搜索节点通信半径内的网络信息。这些信息以信标帧的形式在网络中广播，节点通过主动信道扫描方式获得这些信标帧，然后根据这些信息，找到一个最好的、相对安静的信道，该信道应存在最少的zigbee网络，最好是没有zigbee设备。

4. 配置网络参数（设置网络ID），找到合适的信道后，协调器将为网络选定一个网络标识符（PAN ID），这个ID在所使用的信道中必须唯一，不能和其他zigbee网络冲突，且不能为广播地址0xFFFF（此地址为保留地址，不能使用）。PAN ID可以通过侦听其他网络的ID然后选择一个不会冲突的ID的方式来获取，也可以人为的指定扫描的信道后来确定不和其他网络冲突的PAN ID。

#### 2.1.3 扩展地址和短地址

在zigbee网络中有两种地址模式：扩展地址（64位）和短地址（16位），其中扩展地址由IEEE组织分配，用于唯一的设备标识；

短地址用于本地网络中设备标识，在一个网络中，每个设备的短地址必须唯一，当节点加入网络时短地址由其父节点分配。

对于协调器来说，短地址通常设定为0x0000。

上面步骤完成后，就成功创建了zigbee网络，之后便等待其他节点的加入。

## 3.终端加入网络

### 3.1终端通过协调器入网

为了建立连接，终端需要向协调器发出请求，协调器接收到节点的连接请求后根据情况决定是否允许其连接，然后对请求连接的节点做出响应，终端与协调器建立连接后，才能进行数据的收发。

#### 具体的流程：

1. 搜索网络：终端发送Beacon request

2. 选择父节点：收到Beacon request的潜在父节点回复Beacon帧，此时可能会监听到多个路由节点和多个协调器的Beacon。

终端会选择网络里面`深度最小的作为父节点`，即该`父节点离协调器`最近（协调器的深度最小,所以通过协调器入网时是选择协调器作为父节点）。Beacon 帧里包含了网络panid，父节点短地址。

3. 终端发送关联请求命令（Associate request command），协调器收到关联请求后，根据自己的资源情况（存储空间和能量）决定是否同意此终端的入网请求。

4. 接收入网响应：现在这个节点等待父节点的响应(Association Response)

5. 请求秘钥

6. 发送秘钥：协调器给新入网的设备发送秘钥(Tunnel Transport Key)

7. 设备上报：（Device Announce）

8. 此时可以开始获取新备的设备类型、端点数量、软件版本、硬件版本、厂商信息等

终端入网成功后将得到一个网络短地址，并通过这个地址进行数据的发送和接收，短地址会保存在flash中。



# STM32与MQTT上传、下发

[STM32接入阿里云(FreeRTOS)-实现数据上传和命令下发_stm32更改wifi和密码-CSDN博客](https://blog.csdn.net/NICHUN12345/article/details/123943780?ops_request_misc=&request_id=&biz_id=102&utm_term=STM32与MQTT上传、下发&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-123943780.142^v100^pc_search_result_base7&spm=1018.2226.3001.4187)

**代码需要修改的地方**
1、设置WIFI名称和密码

![在这里插入图片描述](D:\A_Document\Routine_Document\实习\学习\ce84db446f0d4d71b6c2599f778b4c42.png)

2、阿里云服务器的登陆配置

![在这里插入图片描述](D:\A_Document\Routine_Document\实习\学习\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4oG94oG94KyY5pm056m65LiH6YeM4KyT4oG-4oG-,size_20,color_FFFFFF,t_70,g_se,x_16.png)

前3个参数获取方式：

![在这里插入图片描述](D:\A_Document\Routine_Document\实习\学习\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4oG94oG94KyY5pm056m65LiH6YeM4KyT4oG-4oG-,size_20,color_FFFFFF,t_70,g_se,x_16-1713101197217-9.png)

3、数据流名（标识符）修改
将Light、LED修改为你的标识符

![在这里插入图片描述](D:\A_Document\Routine_Document\实习\学习\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4oG94oG94KyY5pm056m65LiH6YeM4KyT4oG-4oG-,size_20,color_FFFFFF,t_70,g_se,x_16-1713101213077-12.png)

标识符查看方式：

![在这里插入图片描述](D:\A_Document\Routine_Document\实习\学习\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4oG94oG94KyY5pm056m65LiH6YeM4KyT4oG-4oG-,size_20,color_FFFFFF,t_70,g_se,x_16-1713101226030-15.png)

**部分代码实现**
main.c文件

```c
#include "stm32f10x.h"
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "bh1750.h"
#include "string.h"

//ESP8266WIFI使用相关头文件
#include "uart2.h"
#include "wifi.h"
#include "timer3.h"
#include "structure.h"

//FreeRTOS系统相关头文件
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

//MQTT协议相关头文件
#include "esp8266_mqtt.h"

//MQTT初始化函数
void ES8266_MQTT_Init(void);

//此处是阿里云服务器的登陆配置
#define MQTT_BROKERADDRESS "a1VPyJEJRjJ.iot-as-mqtt.cn-shanghai.aliyuncs.com"
#define MQTT_CLIENTID "a1VPyJEJRjJ.test01|securemode=2,signmethod=hmacsha256,timestamp=1648914857644|"
#define MQTT_USARNAME "test01&a1VPyJEJRjJ"
#define MQTT_PASSWD "76599f069aff42f644669310490cdc3a9830c5431da41a81ff1467722d2bdb1b"
#define	MQTT_PUBLISH_TOPIC "/sys/a1VPyJEJRjJ/test01/thing/event/property/post"
#define MQTT_SUBSCRIBE_TOPIC "/sys/a1VPyJEJRjJ/test01/thing/service/property/set"

char mqtt_message[300];	//MQTT的上报消息缓存

//服务器IP地址和端口号
char *IP = MQTT_BROKERADDRESS;
int Port = 1883;

//任务优先级
#define START_TASK_PRIO		1
//任务堆栈大小	
#define START_STK_SIZE 		128  
//任务句柄
TaskHandle_t StartTask_Handler;
//任务函数
void start_task(void *pvParameters);

//任务优先级
#define LED0_TASK_PRIO		2
//任务堆栈大小	
#define LED0_STK_SIZE 		50  
//任务句柄
TaskHandle_t LED0Task_Handler;
//任务函数
void led0_task(void *pvParameters);

//任务优先级
#define WIFI_TASK_PRIO		3
//任务堆栈大小	
#define WIFI_STK_SIZE 		512  
//任务句柄
TaskHandle_t WIFITask_Handler;
//任务函数
void wifi_task(void *pvParameters);


/* Uart2 - Wifi 的消息接收队列 */
#define Wifi_MESSAGE_Q_NUM   4   		//接收数据的消息队列的数量
QueueHandle_t Wifi_Message_Queue;		//信息队列句柄

float light ;   //光照值
 
//主函数
int main(void)
{	
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);//设置系统中断优先级分组4 
    delay_init();               //初始化系统时钟
	LED_Init();                 //LED初始化
    uart_init(115200);     	    //初始化串口1
    uart2_init(115200);         //初始化串口2
    Timer3_Configuration(5);    //Tim3定时器，用于wifi-uart2的接收完成
    WiFi_ResetIO_Init();		//wifi - RST引脚初始化
	
    printf("初始化完成，开始创建任务\r\n");
     
    //创建开始任务
    xTaskCreate((TaskFunction_t )start_task,            //任务函数
                (const char*    )"start_task",          //任务名称
                (uint16_t       )START_STK_SIZE,        //任务堆栈大小
                (void*          )NULL,                  //传递给任务函数的参数
                (UBaseType_t    )START_TASK_PRIO,       //任务优先级
                (TaskHandle_t*  )&StartTask_Handler);   //任务句柄              
    vTaskStartScheduler();          //开启任务调度
}
 

 //开始任务任务函数
void start_task(void *pvParameters)
{
    taskENTER_CRITICAL();           //进入临界区
    
    //创建 Uart2 - Wifi 接收消息队列
    Wifi_Message_Queue = xQueueCreate(Wifi_MESSAGE_Q_NUM,1); //队列项数目是Wifi_MESSAGE_Q_NUM，队列项长度是串口DMA接收缓冲区长度
    
    //创建LED0任务
    xTaskCreate((TaskFunction_t )led0_task,     	
                (const char*    )"led0_task",   	
                (uint16_t       )LED0_STK_SIZE, 
                (void*          )NULL,				
                (UBaseType_t    )LED0_TASK_PRIO,	
                (TaskHandle_t*  )&LED0Task_Handler); 

    //创建wifi_task任务
    xTaskCreate((TaskFunction_t )wifi_task,     	
                (const char*    )"wifi_task",   	
                (uint16_t       )WIFI_STK_SIZE, 
                (void*          )NULL,				
                (UBaseType_t    )WIFI_TASK_PRIO,	
                (TaskHandle_t*  )&WIFITask_Handler);   
                
    vTaskDelete(StartTask_Handler); //删除开始任务
    taskEXIT_CRITICAL();            //退出临界区
}

//LED0任务函数 
void led0_task(void *pvParameters)
{
	//光照传感器初始化
    BH1750_Init();
    while(1)
    {
        //printf("led0_task !!!\r\n");
		/* 采集数据 */
		light = LIght_Intensity();	//读取光照强度的值
        vTaskDelay(500);
    }
}   
 
//WIFI任务函数 
void wifi_task(void *pvParameters)
{
	uint8_t pub_cnt = 0,pub_ret;
	uint16_t Counter_MQTT_Heart = 0;
    char *recv;
    //MQTT协议初始化
    ES8266_MQTT_Init();

    while(1)
    {
        //心跳包发送
		if(Counter_MQTT_Heart++>300)
		{
			Counter_MQTT_Heart = 0;
			MQTT_SentHeart();
		}

		/* 发送数据 */
		 pub_cnt++;
		if(0 == pub_cnt%500) //约3S发送一次数据
		{
			pub_cnt = 0;
			memset(mqtt_message, 0, 300);
			//组装数据  
			sprintf(mqtt_message,
			"{\"method\":\"thing.service.property.post\",\"id\":\"1234\",\"params\":{\
			\"Light\":%.1f},\"version\":\"1.0.0\"}", light);
			 //发布数据
			pub_ret = MQTT_PublishData(MQTT_PUBLISH_TOPIC,mqtt_message,0);
			if(pub_ret > 0)
			{
				printf("消息发布成功！！！data=%.1f\r\n", light);
			}
			else
			{
				printf("消息发布失败！！！pub_ret=%d\r\n", pub_ret);
			}
		}
        //收到数据
        if((WifiMsg.U2_RxCompleted == 1) && (Usart2_RxCounter > 1))
        {
            printf("来自服务器数据：%d\r\n", Usart2_RxCounter);
			recv = strstr(Usart2_RxBuff, "LED"); 
            //下发命令后，串口2会接收到这样的数据：
			//...{"method":"thing.service.property.set","id":"1593428732","params":{"LED":1},"version":"1.0.0"}			
            if(recv != NULL)
            {	
				//经过strstr函数后，recv指向了字符串：LED":0}...
				//为拿到LED后面的状态值，指针偏移5个字节
				recv = recv + 3 +2;  //LED占3个字节  ”:占2个字节
                printf("LED=%d\r\n", (*recv)-'0');
                LED0 = !((*recv)-'0');  //根据下发的命令控制PC13处的LED灯
            
                memset(mqtt_message, 0, 300);
                //组装数据  id 1454479553
                sprintf(mqtt_message,
                "{\"method\":\"thing.service.property.set\",\"id\":\"5678\",\"params\":{\
                \"LED\":%d},\"version\":\"1.0.0\"}", (*recv)-'0');
                
                //发布数据
                pub_ret = MQTT_PublishData(MQTT_PUBLISH_TOPIC,mqtt_message,0);
                if(pub_ret > 0)
                {
                    printf("消息发布成功！！！pub_ret=%d\r\n", pub_ret);
                }
                else
                {
                    printf("消息发布失败！！！pub_ret=%d\r\n", pub_ret);
                }
            }
            //将标志位和数据清空
            memset(Usart2_RxBuff, 0, sizeof(Usart2_RxBuff));
            WifiMsg.U2_RxCompleted = 0;
            Usart2_RxCounter = 0;
        } 
        vTaskDelay(10);
    }
} 

```



# 红外控制空调

[stm32格力空调遥控- CSDN搜索](https://so.csdn.net/so/search?spm=1001.2101.3001.7499&q=stm32格力空调遥控&t=&u=&utm_medium=distribute.pc_search_hot_word.none-task-hot_word-alirecmd-2-stm32格力空调遥控-null-null.172^v8^tag_flag&depth_1-utm_source=distribute.pc_search_hot_word.none-task-hot_word-alirecmd-2-stm32格力空调遥控-null-null.172^v8^tag_flag)

[基于STM32的格力空调红外控制_stm32 格力空调-CSDN博客](https://blog.csdn.net/weixin_44453694/article/details/132072490?ops_request_misc=%7B%22request%5Fid%22%3A%22171310204916800178553068%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=171310204916800178553068&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-132072490-null-null.142^v100^pc_search_result_base7&utm_term=stm32格力空调遥控&spm=1018.2226.3001.4187)

其他红外介绍不多说了，下面介绍一下我[使用stm32](https://so.csdn.net/so/search?q=使用stm32&spm=1001.2101.3001.7020)控制格力空调所遇到问题。

### 1.红外实现过程中遇到的问题

  网上大部分对格力空调红外编码的介绍都是

  **起始码（S）+35位数据码+连接码（C）+32位数据码**

0的电平宽度为：620us低电平+540us高电平，

1的电平宽度为：620us低电平+1620us高电平

起始码S电平宽度为：9000us低电平+4500us高电平

连接码C电平宽度为：620us低电平+20000us高电平

以上是在接受端的定义，要注意分辨。发射端是相反的

红外发射端的波形。
![74815d1f91b445faa56bb5f20da38639.png](D:\A_Document\Routine_Document\实习\学习\74815d1f91b445faa56bb5f20da38639.png)

红外接受端是以下这种

![366726d11e8d467a975c66096662340b.png](D:\A_Document\Routine_Document\实习\学习\366726d11e8d467a975c66096662340b.png)

两者是[不同的](https://so.csdn.net/so/search?q=不同的&spm=1001.2101.3001.7020)。网上大多是第二种容易产生误解。

格力空调的编码如下图—

![d799f9a0f461468082b8a6ae26d8b2b7.png](D:\A_Document\Routine_Document\实习\学习\d799f9a0f461468082b8a6ae26d8b2b7.png)

网上的格式都大同小异对红外的编码产生的影响不大。

根据实际的使用，我发现我所使用的遥控器是如下这中格式，末尾的连接码不可缺少。

**起始码（S）+35位数据码+连接码（C）+32位数据码+连接码（C）**

而且[红外遥控器](https://so.csdn.net/so/search?q=红外遥控器&spm=1001.2101.3001.7020)会以两倍的连接码时间间隔发送两次命令。

以上是我实现红外过程中遇到的问题

### 2.实现方法

使用stm32的pwm功能发出38kHz的载波，然后控制占空比以达到高低电平的实现。

```c
//38kHz初始化
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);	//打开定时器2的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);	//打开GPIOA的时钟			/*注意：只有部分端口才有PWM功能*/
 
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	TIM_InternalClockConfig(TIM2);	//设置定时器2的时钟源为内部时钟源
	
	TIM_TimeBaseInitTypeDef TimBaseInitStructure;		//设置时基单元
	TimBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;		
	TimBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; 	//设置计数模式为向上计数
	TimBaseInitStructure.TIM_Period = 101-1;		//ARR(自动重装器，设置计数峰值)
	TimBaseInitStructure.TIM_Prescaler = 19-1;		//PSC(预分频器，设置计时频率)
	TimBaseInitStructure.TIM_RepetitionCounter = 0;	//设置计数重装值
	TIM_TimeBaseInit(TIM2, &TimBaseInitStructure);
	
	TIM_OCInitTypeDef TIM_OCInitStructure;		//设置输出比较单元
	TIM_OCStructInit(&TIM_OCInitStructure);		//先对TIM_OCInitStructure所有成员赋值，之后只会对部分成员重新赋值，防止出现部分成员未赋值情况
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;	//设置输出比较模式为PWM1模式
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;	//输出比较极性（设置REF，有效电平为高电平）
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;	//输出状态使能
	TIM_OCInitStructure.TIM_Pulse = 0;		//CRR(输出比较值)
	TIM_OC2Init(TIM2,&TIM_OCInitStructure);	//使用输出比较通道2
  TIM_Cmd(TIM2,ENABLE);	//定时器2使能
```

```c
typedef struct{
    // Byte 0
    uint8_t Mode      :3;
    uint8_t Power     :1;
    uint8_t Fan       :2;
    uint8_t SwingAuto :1;
    uint8_t Sleep     :1;
    // Byte 1
    uint8_t Temp        :4;
    uint8_t TimerHalfHr :1;
    uint8_t TimerTensHr :2;
    uint8_t TimerEnabled:1;
    // Byte 2
    uint8_t TimerHours:4;
    uint8_t Turbo     :1;
    uint8_t Light     :1;
    uint8_t anion     :1;  // model==YAW1F
    uint8_t Powersv   :1;
    // Byte 3
    uint8_t unknown0        :2;//00
    uint8_t TempExtraDegreeF:1;
    uint8_t UseFahrenheit   :1;
    uint8_t unknown1        :4;  // value=0b0101
    // Byte 4
    uint8_t SwingV      :4;
    uint8_t SwingH      :3;
    uint8_t unknown2     :1; //0
    // Byte 5
    uint8_t DisplayTemp :2;
    uint8_t IFeel       :1;
    uint8_t unknown3    :3;  // value = 0b100 
    uint8_t WiFi        :1;  //0
    uint8_t unknown4    :1;    //0
    // Byte 6
    uint8_t unknown5   :8;  //00000000
    // Byte 7
    uint8_t unknown6    :2; //00
    uint8_t Econo       :1;
    uint8_t unknown7    :1;//0
    uint8_t Sum         :4;
  }Protocol;
//红外码初始化
```

```c
void IR_Send38kHz(uint16_t time,FunctionalState NewState){
	if(NewState == 1){
		TIM_SetCompare2(TIM2,0);
	  Delay_us(time);}
	else
	{
		TIM_SetCompare2(TIM2,50);
	  Delay_us(time);
	}
};
 
void IR_SendGreeH(void){
    TIM_SetCompare2(TIM2,50);
	  Delay_us(GreeBitMark);
	  TIM_SetCompare2(TIM2,0);
	  Delay_us(GreeOneSpace);
};
 
void IR_SendGreeL(void){
    TIM_SetCompare2(TIM2,50);
	  Delay_us(GreeBitMark);
	  TIM_SetCompare2(TIM2,0);
	  Delay_us(GreeZeroSpace);
};
 
void IR_SendMsg(uint8_t cnt,uint8_t data){
     while(cnt--){
	   if(data&0x01){
     IR_SendGreeH();
		 data=data>>1;}
		 else{
		 IR_SendGreeL();
		 data=data>>1;
		 }
	 }
};
```

特别注意校验码的计算，网上有很多公式。下面我给出一种

校验码 = [(模式 – 1) + (温度 – 16) + 5 +左右扫风+换气+节能]取二进制后四位；

### 3.或者

#### 1.采集红外信号

通过上图红外接收设备，捕获红外信号，利用逻辑分析仪分析捕获的数据内容。捕获波形如下：

#### 2.波形数据分析

得到 **开空调波形**、 **关空调波形**

#### 3.输入捕获方式采集红外数据

- 为了编译后续学习实现空调的开机和关键功能，首先可以通过红外接收头采集实际键值数据，通过定时器输入捕获方式将键值数据进行保存。
- 本次红外案例红外接收头接入到开发板的PB9引脚，通过定时器4输入捕获进行数据采集

**定时器输入捕获配置**

```c
/***********************定时器4输入捕获配置***********************
**               没有重映像          完全重映像
**TIM4_CH1          PB6                   PD12
**TIM4_CH2          PB7                   PD13
**TIM4_CH3          PB8                   PD14
**TIM4_CH4          PB9                   PD15
**
******************************************************************/

void TIM4_Input_Init(u16 psc,u16 arr)//72
{
	RCC->APB2ENR|=1<<3;//PB
	GPIOB->CRH&=~(0xF<<1*4);
	GPIOB->CRH|=0x8<<1*4;
	/*定时器配置*/
	RCC->APB1ENR|=1<<2;//TIM4
	RCC->APB1RSTR|=1<<2;
	RCC->APB1RSTR&=~(1<<2);
	TIM4->CNT=0;
	TIM4->PSC=psc-1;
	TIM4->ARR=arr;
	/*配置定时器输入捕获模式*/
	TIM4->CCMR2|=0x1<<8;//CH4配置为输入，CCR4保存CH4数据
	TIM4->CCER|=1<<13;//捕获发生在下降沿
	TIM4->DIER|=1<<4;//开启捕获中断
	STM32_NVIC_SetPriority(TIM4_IRQn,1,1);//设置优先级
	TIM4->CCER|=1<<12;//开启CH1输入捕获
	TIM4->CR1|=1<<0;//开启定时器
}

```

**红外数据采集示例**

```c
char buff[100];
u8 buff_data=0;
/**************TIM4中断服务函数***************/
void TIM4_IRQHandler(void)
{
	u16 time;
	u8 static recv_stat=0;
	u8 static i=0;
	if(TIM4->SR&1<<0)
	{
	
	}
	if(TIM4->SR&1<<4)//捕获中断
	{
		TIM4->CNT=0;
		time=TIM4->CCR4;
		if(TIM4_CH4)//上升沿触发
		{
			TIM4->CCER|=1<<13;//下一次捕获下降沿
			if(recv_stat==0)//开始接收引导码
			{
				if(time>=8000 && time<=10000)recv_stat=1;//成功接收9ms低电平
				else recv_stat=0;
			}
			else if(recv_stat==2)
			{
				//printf("引导码接收成功\r\n");
				if(time<550 || time>750) recv_stat=0;//650us间隔时间接收失败
			}
		}
		else //下降沿触发
		{
			TIM4->CCER&=~(1<<13);//下一次捕获上升沿
			if(recv_stat==1)
			{
				if(time>=3500 && time<=5500)recv_stat=2;//引导码接收成功:9ms低+4.5高
				else recv_stat=0;
			}
			else if(recv_stat==2)//开始接收实际数据
			{
					if(time>=400 && time<=650)//数据0:650us低+530us高
					{
						buff[i++]=0;
					}
					else if(time>=1500 && time<=1700)//数据1:650us低+1.6ms高
					{
						buff[i++]=1;
					}
					else if(time>=18000 && time<=21000)
					{
						buff[i++]=2;//间隔
					}
					else if(time>=38000 && time<=42000)
					{
						//printf("i=%d\r\n",i);
						buff_data=i;
						recv_stat=0;
						i=0;
						infrared_flag=3;
					}
					else 
					{
						i=0;
						recv_stat=0;
						infrared_data=0;
					}
			}
		}
	}
	TIM4->SR=0;//清除标志
}

```

![在这里插入图片描述](D:\A_Document\Routine_Document\实习\学习\783df414fcc24505a11ca3b8bbb01b75.png)

#### 4.开关机学习示例

#### 4.1 38KHZ载波信号发送

  本次使用的红外发射模块工作频率为38KHZ，发送数据高低电平采用1:1方式。发送高电平需要发送38KHZ的方波脉冲信号(高低电平1:1方式)，发送第低低电平则直接将引脚拉低即可。

```C
/*****************发送38KHZ载波*********************
**38KHZ载波：1/38000HZ=26us，按照高低电平1:1发送载波
**形参：u32 time --持续时间
**u8 stat --转态(1表示发送，0表示不发送)
*****************************************************/
void Infrared_Send38KHZ(u32 time,u8 stat)
{
	u32 i=0;
	if(stat)
	{
		for(i=0;i<time/13;i++)
		{
			RED_IE=!RED_IE;
			DelayUs(13);
		}
	}
	else//发送低电平
	{
		RED_IE=0;
		DelayUs(time);
	}
}

```

#### 4.2 开关键值发送函数示例

```C
//格力空调协议数据发送
void Infrared_GreeSendData(u8*data,int cnt)
{
	/*1.发送9ms低电平*/
	Infrared_Send38KHZ(9000,1);
	/*2.发送4.5ms高电平*/
	Infrared_Send38KHZ(4500,0);	
	u32 i;
	for(i=0;i<cnt;i++)
	{
		Infrared_Send38KHZ(650,1);//发送间隔时间，650us的低电平
		if(data[i]=='1')
			Infrared_Send38KHZ(1600,0);//数据1
		else if(data[i]=='0')
			Infrared_Send38KHZ(530,0);//数据0
		else if(data[i]=='2')
			Infrared_Send38KHZ(20000,0);//间隔码
	}
	Infrared_Send38KHZ(650,1);//发送间隔时间，650us的低电平
	Infrared_Send38KHZ(40000,0);//间隔码
	
	/*1.发送9ms低电平*/
	Infrared_Send38KHZ(9000,1);
	/*2.发送4.5ms高电平*/
	Infrared_Send38KHZ(4500,0);	
	for(i=0;i<cnt;i++)
	{
		Infrared_Send38KHZ(650,1);//发送间隔时间，650us的低电平
		if(data[i]=='1')
			Infrared_Send38KHZ(1600,0);//数据1
		else if(data[i]=='0')
			Infrared_Send38KHZ(530,0);//数据0
		else if(data[i]=='2')
			Infrared_Send38KHZ(20000,0);//间隔码
	}
	Infrared_Send38KHZ(650,1);//发送间隔时间，650us的低电平
}

```

# 安卓

[stm32 app 连上阿里云_stm32与云平台或者app之间的通信方法-CSDN博客](https://blog.csdn.net/weixin_45642495/article/details/118069124?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32安卓app阿里云控制舵机&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-118069124.142^v100^pc_search_result_base7&spm=1018.2226.3001.4187)

```c
细心的我把代码留下
package com.example.smart_window;

import android.annotation.SuppressLint;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

//MainActivity依赖AppCompatActivity
public class MainActivity extends AppCompatActivity {

private String host = "tcp://a1IGfJFIYk1.iot-as-mqtt.cn-shanghai.aliyuncs.com:1883";
private String mqtt_id = "software|securemode=3,signmethod=hmacsha1,timestamp=789|"; 
private String userName = "software&a1IGfJFIYk1";
private String passWord = "b400896f719f6c3794dd9ba8e798d6de72ac7ac3";

private String mqtt_sub_topic = "/a1mFXDKSRyr/my_app/user/ad"; //本次只连 未验证  收发
private String mqtt_pub_topic = "/a1mFXDKSRyr/my_app/user/data"; 

private MqttClient client;
private MqttConnectOptions options;
private Handler handler;
private ScheduledExecutorService scheduler;




@SuppressLint("HandlerLeak")
@Override
protected void onCreate(Bundle savedInstanceState) {
    //这里是界面打开后 最先运行的地方
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main); //对应界面UI


    Mqtt_init();
    startReconnect();

    handler = new Handler() {
        @SuppressLint("SetTextI18n")
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what){
                case 1: //开机校验更新回传
                    break;
                case 2:  // 反馈回传

                    break;
                case 3:  //MQTT 收到消息回传   UTF8Buffer msg=new UTF8Buffer(object.toString());


                    break;
                case 30:  //连接失败
                    Toast.makeText(MainActivity.this,"连接失败" ,Toast.LENGTH_SHORT).show();
                    break;
                case 31:   //连接成功
                    Toast.makeText(MainActivity.this,"连接成功" ,Toast.LENGTH_SHORT).show();
                    try {
                        client.subscribe(mqtt_sub_topic,1);
                    } catch (MqttException e) {
                        e.printStackTrace();
                    }
                    break;
                default:
                    break;
            }
        }
    };
}



private void parseJSONWithJSONObject(String JsonData) { //解析json数据
    try
    {
      
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}


private void Mqtt_init()
{
    try {
        //host为主机名，test为clientid即连接MQTT的客户端ID，一般以客户端唯一标识符表示，MemoryPersistence设置clientid的保存形式，默认为以内存保存
        client = new MqttClient(host, mqtt_id,
                new MemoryPersistence());
        //MQTT的连接设置
        options = new MqttConnectOptions();
        //设置是否清空session,这里如果设置为false表示服务器会保留客户端的连接记录，这里设置为true表示每次连接到服务器都以新的身份连接
        options.setCleanSession(false);
        //设置连接的用户名
        options.setUserName(userName);
        //设置连接的密码
        options.setPassword(passWord.toCharArray());
        // 设置超时时间 单位为秒
        options.setConnectionTimeout(30);
        // 设置会话心跳时间 单位为秒 服务器会每隔1.5*20秒的时间向客户端发送个消息判断客户端是否在线，但这个方法并没有重连的机制
        options.setKeepAliveInterval(100);
        //设置回调
        client.setCallback(new MqttCallback() {
            @Override
            public void connectionLost(Throwable cause) {
                //连接丢失后，一般在这里面进行重连
                System.out.println("connectionLost----------");
                //startReconnect();
            }
            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {
                //publish后会执行到这里
                System.out.println("deliveryComplete---------"
                        + token.isComplete());
            }
            @Override
            public void messageArrived(String topicName, MqttMessage message)
                    throws Exception {
                //subscribe后得到的消息会执行到这里面
                System.out.println("messageArrived----------");
                Message msg = new Message();
                msg.what = 3;   //收到消息标志位
                msg.obj = topicName + "---" + message.toString();
                handler.sendMessage(msg);    // hander 回传
            }
        });
    } catch (Exception e) {
        e.printStackTrace();
    }
}
private void Mqtt_connect() {
    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                if(!(client.isConnected()) )  //如果还未连接
                {
                    client.connect(options);
                    Message msg = new Message();
                    msg.what = 31;
                    handler.sendMessage(msg);
                }
            } catch (Exception e) {
                e.printStackTrace();
                Message msg = new Message();
                msg.what = 30;
                handler.sendMessage(msg);
            }
        }
    }).start();
}
private void startReconnect() {
    scheduler = Executors.newSingleThreadScheduledExecutor();
    scheduler.scheduleAtFixedRate(new Runnable() {
        @Override
        public void run() {
            if (!client.isConnected()) {
                Mqtt_connect();
            }
        }
    }, 0 * 1000, 10 * 1000, TimeUnit.MILLISECONDS);
}
private void publishmessageplus(String topic,String message2)
{
    if (client == null || !client.isConnected()) {
        return;
    }
    MqttMessage message = new MqttMessage();
    message.setPayload(message2.getBytes());
    try {
        client.publish(topic,message);
    } catch (MqttException e) {

        e.printStackTrace();
    }
}

```

